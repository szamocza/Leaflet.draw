{"version":3,"sources":["src/Leaflet.draw.js","src/Leaflet.Draw.Event.js","src/draw/handler/Draw.Feature.js","src/draw/handler/Draw.Polyline.js","src/draw/handler/Draw.Polygon.js","src/draw/handler/Draw.SimpleShape.js","src/draw/handler/Draw.Rectangle.js","src/draw/handler/Draw.Marker.js","src/draw/handler/Draw.CircleMarker.js","src/draw/handler/Draw.Circle.js","src/draw/handler/Draw.Cloud.js","src/draw/handler/Draw.Arrow.js","src/edit/handler/Edit.Marker.js","src/edit/handler/Edit.Poly.js","src/edit/handler/Edit.SimpleShape.js","src/edit/handler/Edit.Rectangle.js","src/edit/handler/Edit.CircleMarker.js","src/edit/handler/Edit.Circle.js","src/ext/TouchEvents.js","src/ext/LatLngUtil.js","src/ext/GeometryUtil.js","src/ext/LineUtil.Intersect.js","src/ext/Polyline.Intersect.js","src/ext/Polygon.Intersect.js","src/Control.Draw.js","src/Toolbar.js","src/Tooltip.js","src/draw/DrawToolbar.js","src/edit/EditToolbar.js","src/edit/handler/EditToolbar.Edit.js","src/edit/handler/EditToolbar.Delete.js"],"names":[],"mappings":";;;;;;;yCAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\r\n * Leaflet.draw assumes that you have already included the Leaflet library.\r\n */\r\nL.drawVersion = \"0.4.12+47a98db\";\r\n/**\r\n * @class L.Draw\r\n * @aka Draw\r\n *\r\n *\r\n * To add the draw toolbar set the option drawControl: true in the map options.\r\n *\r\n * @example\r\n * ```js\r\n *      var map = L.map('map', {drawControl: true}).setView([51.505, -0.09], 13);\r\n *\r\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n *      }).addTo(map);\r\n * ```\r\n *\r\n * ### Adding the edit toolbar\r\n * To use the edit toolbar you must initialise the Leaflet.draw control and manually add it to the map.\r\n *\r\n * ```js\r\n *      var map = L.map('map').setView([51.505, -0.09], 13);\r\n *\r\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n *      }).addTo(map);\r\n *\r\n *      // FeatureGroup is to store editable layers\r\n *      var drawnItems = new L.FeatureGroup();\r\n *      map.addLayer(drawnItems);\r\n *\r\n *      var drawControl = new L.Control.Draw({\r\n *          edit: {\r\n *              featureGroup: drawnItems\r\n *          }\r\n *      });\r\n *      map.addControl(drawControl);\r\n * ```\r\n *\r\n * The key here is the featureGroup option. This tells the plugin which FeatureGroup contains the layers that\r\n * should be editable. The featureGroup can contain 0 or more features with geometry types Point, LineString, and Polygon.\r\n * Leaflet.draw does not work with multigeometry features such as MultiPoint, MultiLineString, MultiPolygon,\r\n * or GeometryCollection. If you need to add multigeometry features to the draw plugin, convert them to a\r\n * FeatureCollection of non-multigeometries (Points, LineStrings, or Polygons).\r\n */\r\nL.Draw = {};\r\n\r\n/**\r\n * @class L.drawLocal\r\n * @aka L.drawLocal\r\n *\r\n * The core toolbar class of the API — it is used to create the toolbar ui\r\n *\r\n * @example\r\n * ```js\r\n *      var modifiedDraw = L.drawLocal.extend({\r\n *          draw: {\r\n *              toolbar: {\r\n *                  buttons: {\r\n *                      polygon: 'Draw an awesome polygon'\r\n *                  }\r\n *              }\r\n *          }\r\n *      });\r\n * ```\r\n *\r\n * The default state for the control is the draw toolbar just below the zoom control.\r\n *  This will allow map users to draw vectors and markers.\r\n *  **Please note the edit toolbar is not enabled by default.**\r\n */\r\nL.drawLocal = {\r\n\t// format: {\r\n\t// \tnumeric: {\r\n\t// \t\tdelimiters: {\r\n\t// \t\t\tthousands: ',',\r\n\t// \t\t\tdecimal: '.'\r\n\t// \t\t}\r\n\t// \t}\r\n\t// },\r\n\tdraw: {\r\n\t\ttoolbar: {\r\n\t\t\t// #TODO: this should be reorganized where actions are nested in actions\r\n\t\t\t// ex: actions.undo  or actions.cancel\r\n\t\t\tactions: {\r\n\t\t\t\ttitle: 'Cancel drawing',\r\n\t\t\t\ttext: 'Cancel'\r\n\t\t\t},\r\n\t\t\tfinish: {\r\n\t\t\t\ttitle: 'Finish drawing',\r\n\t\t\t\ttext: 'Finish'\r\n\t\t\t},\r\n\t\t\tundo: {\r\n\t\t\t\ttitle: 'Delete last point drawn',\r\n\t\t\t\ttext: 'Delete last point'\r\n\t\t\t},\r\n\t\t\tbuttons: {\r\n\t\t\t\tpolyline: 'Draw a polyline',\r\n\t\t\t\tpolygon: 'Draw a polygon',\r\n\t\t\t\trectangle: 'Draw a rectangle',\r\n\t\t\t\tcircle: 'Draw a circle',\r\n\t\t\t\tmarker: 'Draw a marker',\r\n\t\t\t\tcirclemarker: 'Draw a circlemarker'\r\n\t\t\t}\r\n\t\t},\r\n\t\thandlers: {\r\n\t\t\tcircle: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click and drag to draw circle.'\r\n\t\t\t\t},\r\n\t\t\t\tradius: 'Radius'\r\n\t\t\t},\r\n\t\t\tcirclemarker: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click map to place circle marker.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmarker: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click map to place marker.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tpolygon: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click to start drawing shape.',\r\n\t\t\t\t\tcont: 'Click to continue drawing shape.',\r\n\t\t\t\t\tend: 'Click first point to close this shape.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tpolyline: {\r\n\t\t\t\terror: '<strong>Error:</strong> shape edges cannot cross!',\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click to start drawing line.',\r\n\t\t\t\t\tcont: 'Click to continue drawing line.',\r\n\t\t\t\t\tend: 'Click last point to finish line.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\trectangle: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click and drag to draw rectangle.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsimpleshape: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tend: 'Release mouse to finish drawing.'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tedit: {\r\n\t\ttoolbar: {\r\n\t\t\tactions: {\r\n\t\t\t\tsave: {\r\n\t\t\t\t\ttitle: 'Save changes',\r\n\t\t\t\t\ttext: 'Save'\r\n\t\t\t\t},\r\n\t\t\t\tcancel: {\r\n\t\t\t\t\ttitle: 'Cancel editing, discards all changes',\r\n\t\t\t\t\ttext: 'Cancel'\r\n\t\t\t\t},\r\n\t\t\t\tclearAll:{\r\n\t\t\t\t\ttitle: 'Clear all layers',\r\n\t\t\t\t\ttext: 'Clear All'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tbuttons: {\r\n\t\t\t\tedit: 'Edit layers',\r\n\t\t\t\teditDisabled: 'No layers to edit',\r\n\t\t\t\tremove: 'Delete layers',\r\n\t\t\t\tremoveDisabled: 'No layers to delete'\r\n\t\t\t}\r\n\t\t},\r\n\t\thandlers: {\r\n\t\t\tedit: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\ttext: 'Drag handles or markers to edit features.',\r\n\t\t\t\t\tsubtext: 'Click cancel to undo changes.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tremove: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\ttext: 'Click on a feature to remove.'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n","/**\n * ### Events\n * Once you have successfully added the Leaflet.draw plugin to your map you will want to respond to the different\n * actions users can initiate. The following events will be triggered on the map:\n *\n * @class L.Draw.Event\n * @aka Draw.Event\n *\n * Use `L.Draw.Event.EVENTNAME` constants to ensure events are correct.\n *\n * @example\n * ```js\n * map.on(L.Draw.Event.CREATED; function (e) {\n *    var type = e.layerType,\n *        layer = e.layer;\n *\n *    if (type === 'marker') {\n *        // Do marker specific actions\n *    }\n *\n *    // Do whatever else you need to. (save to db; add to map etc)\n *    map.addLayer(layer);\n *});\n * ```\n */\nL.Draw.Event = {};\n/**\n * @event draw:created: PolyLine; Polygon; Rectangle; Circle; Marker | String\n *\n * Layer that was just created.\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\n * Triggered when a new vector or marker has been created.\n *\n */\nL.Draw.Event.CREATED = 'draw:created';\n\n/**\n * @event draw:edited: LayerGroup\n *\n * List of all layers just edited on the map.\n *\n *\n * Triggered when layers in the FeatureGroup; initialised with the plugin; have been edited and saved.\n *\n * @example\n * ```js\n *      map.on('draw:edited', function (e) {\n     *          var layers = e.layers;\n     *          layers.eachLayer(function (layer) {\n     *              //do whatever you want; most likely save back to db\n     *          });\n     *      });\n * ```\n */\nL.Draw.Event.EDITED = 'draw:edited';\n\n/**\n * @event draw:deleted: LayerGroup\n *\n * List of all layers just removed from the map.\n *\n * Triggered when layers have been removed (and saved) from the FeatureGroup.\n */\nL.Draw.Event.DELETED = 'draw:deleted';\n\n/**\n * @event draw:drawstart: String\n *\n * The type of layer this is. One of:`polyline`; `polygon`; `rectangle`; `circle`; `marker`\n *\n * Triggered when the user has chosen to draw a particular vector or marker.\n */\nL.Draw.Event.DRAWSTART = 'draw:drawstart';\n\n/**\n * @event draw:drawstop: String\n *\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\n *\n * Triggered when the user has finished a particular vector or marker.\n */\n\nL.Draw.Event.DRAWSTOP = 'draw:drawstop';\n\n/**\n * @event draw:drawvertex: LayerGroup\n *\n * List of all layers just being added from the map.\n *\n * Triggered when a vertex is created on a polyline or polygon.\n */\nL.Draw.Event.DRAWVERTEX = 'draw:drawvertex';\n\n/**\n * @event draw:editstart: String\n *\n * The type of edit this is. One of: `edit`\n *\n * Triggered when the user starts edit mode by clicking the edit tool button.\n */\n\nL.Draw.Event.EDITSTART = 'draw:editstart';\n\n/**\n * @event draw:editmove: ILayer\n *\n *  Layer that was just moved.\n *\n * Triggered as the user moves a rectangle; circle or marker.\n */\nL.Draw.Event.EDITMOVE = 'draw:editmove';\n\n/**\n * @event draw:editresize: ILayer\n *\n * Layer that was just moved.\n *\n * Triggered as the user resizes a rectangle or circle.\n */\nL.Draw.Event.EDITRESIZE = 'draw:editresize';\n\n/**\n * @event draw:editvertex: LayerGroup\n *\n * List of all layers just being edited from the map.\n *\n * Triggered when a vertex is edited on a polyline or polygon.\n */\nL.Draw.Event.EDITVERTEX = 'draw:editvertex';\n\n/**\n * @event draw:editstop: String\n *\n * The type of edit this is. One of: `edit`\n *\n * Triggered when the user has finshed editing (edit mode) and saves edits.\n */\nL.Draw.Event.EDITSTOP = 'draw:editstop';\n\n/**\n * @event draw:deletestart: String\n *\n * The type of edit this is. One of: `remove`\n *\n * Triggered when the user starts remove mode by clicking the remove tool button.\n */\nL.Draw.Event.DELETESTART = 'draw:deletestart';\n\n/**\n * @event draw:deletestop: String\n *\n * The type of edit this is. One of: `remove`\n *\n * Triggered when the user has finished removing shapes (remove mode) and saves.\n */\nL.Draw.Event.DELETESTOP = 'draw:deletestop';\n","L.Draw = L.Draw || {};\r\n\r\n/**\r\n * @class L.Draw.Feature\r\n * @aka Draw.Feature\r\n */\r\nL.Draw.Feature = L.Handler.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tthis._map = map;\r\n\t\tthis._container = map._container;\r\n\t\tthis._overlayPane = map._panes.overlayPane;\r\n\t\tthis._popupPane = map._panes.popupPane;\r\n\r\n\t\t// Merge default shapeOptions options with custom shapeOptions\r\n\t\tif (options && options.shapeOptions) {\r\n\t\t\toptions.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);\r\n\t\t}\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enables this handler\r\n\tenable: function () {\r\n\t\tif (this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\r\n\t\tthis.fire('enabled', { handler: this.type });\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DRAWSTART, { layerType: this.type });\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DRAWSTOP, { layerType: this.type });\r\n\r\n\t\tthis.fire('disabled', { handler: this.type });\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add's event listeners to this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Removes event listeners from this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tL.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method setOptions(object): void\r\n\t// Sets new options to this handler\r\n\tsetOptions: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t_fireCreatedEvent: function (layer) {\r\n\t\tthis._map.fire(L.Draw.Event.CREATED, { layer: layer, layerType: this.type });\r\n\t},\r\n\r\n\t// Cancel drawing when the escape key is pressed\r\n\t_cancelDrawing: function (e) {\r\n\t\tif (e.keyCode === 27) {\r\n\t\t\tthis._map.fire('draw:canceled', { layerType: this.type });\r\n\t\t\tthis.disable();\r\n\t\t}\r\n\t}\r\n});\r\n","/**\n * @class L.Draw.Polyline\n * @aka Draw.Polyline\n * @inherits L.Draw.Feature\n */\nL.Draw.Polyline = L.Draw.Feature.extend({\n\tstatics: {\n\t\tTYPE: 'polyline'\n\t},\n\n\tPoly: L.Polyline,\n\n\toptions: {\n\t\tallowIntersection: true,\n\t\trepeatMode: false,\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 2500\n\t\t},\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tguidelineDistance: 20,\n\t\tmaxGuideLineLength: 4000,\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: false,\n\t\t\tclickable: true\n\t\t},\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\n\t\tshowLength: true, // Whether to display distance in the tooltip\n    zIndexOffset: 2000, // This should be > than the highest z-index any map layers\n    factor: 1 // To change distance calculation\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\n\t\t// Need to set this here to ensure the correct message is used.\n\t\tthis.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;\n\n\t\t// Merge default drawError options with custom options\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Polyline.TYPE;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._markers = [];\n\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t\tthis._map.addLayer(this._markerGroup);\n\n\t\t\tthis._poly = new L.Polyline([], this.options.shapeOptions);\n\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\n\t\t\t// Make a transparent marker that will used to catch click events. These click\n\t\t\t// events will create the vertices. We need to do this so we can ensure that\n\t\t\t// we can create vertices over other map layers (markers, vector layers). We\n\t\t\t// also do not want to trigger any click handlers of objects we are clicking on\n\t\t\t// while drawing.\n\t\t\tif (!this._mouseMarker) {\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\n\t\t\t\t\ticon: L.divIcon({\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\n\t\t\t\t\t\ticonAnchor: [20, 20],\n\t\t\t\t\t\ticonSize: [40, 40]\n\t\t\t\t\t}),\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseMarker\n\t\t\t\t.on('mouseout', this._onMouseOut, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this) // Necessary to prevent 0.8 stutter\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.8 compatibility\n\t\t\t\t.addTo(this._map);\n\n\t\t\tthis._map\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.7 compatibility\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t\t.on('touchstart', this._onTouch, this)\n\t\t\t\t.on('zoomend', this._onZoomEnd, this);\n\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\tthis._cleanUpShape();\n\n\t\t// remove markers from map\n\t\tthis._map.removeLayer(this._markerGroup);\n\t\tdelete this._markerGroup;\n\t\tdelete this._markers;\n\n\t\tthis._map.removeLayer(this._poly);\n\t\tdelete this._poly;\n\n\t\tthis._mouseMarker\n\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t.off('mouseout', this._onMouseOut, this)\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this);\n\t\tthis._map.removeLayer(this._mouseMarker);\n\t\tdelete this._mouseMarker;\n\n\t\t// clean up DOM\n\t\tthis._clearGuides();\n\n\t\tthis._map\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t.off('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t.off('zoomend', this._onZoomEnd, this)\n\t\t\t.off('touchstart', this._onTouch, this)\n\t\t\t.off('click', this._onTouch, this);\n\t},\n\n\t// @method deleteLastVertex(): void\n\t// Remove the last vertex from the polyline, removes polyline from map if only one point exists.\n\tdeleteLastVertex: function () {\n\t\tif (this._markers.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lastMarker = this._markers.pop(),\n\t\t\tpoly = this._poly,\n\t\t\t// Replaces .spliceLatLngs()\n\t\t\tlatlngs = poly.getLatLngs(),\n\t\t\tlatlng = latlngs.splice(-1, 1)[0];\n\t\tthis._poly.setLatLngs(latlngs);\n\n\t\tthis._markerGroup.removeLayer(lastMarker);\n\n\t\tif (poly.getLatLngs().length < 2) {\n\t\t\tthis._map.removeLayer(poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, false);\n\t},\n\n\t// @method addVertex(): void\n\t// Add a vertex to the end of the polyline\n\taddVertex: function (latlng) {\n\t\tvar markersLength = this._markers.length;\n\t\t// markersLength must be greater than or equal to 2 before intersections can occur\n\t\tif (markersLength >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\t\telse if (this._errorShown) {\n\t\t\tthis._hideErrorTooltip();\n\t\t}\n\n\t\tthis._markers.push(this._createMarker(latlng));\n\n\t\tthis._poly.addLatLng(latlng);\n\n\t\tif (this._poly.getLatLngs().length === 2) {\n\t\t\tthis._map.addLayer(this._poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, true);\n\t},\n\n\t// @method completeShape(): void\n\t// Closes the polyline between the first and last points\n\tcompleteShape: function () {\n\t\tif (this._markers.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t_finishShape: function () {\n\t\tvar latlngs = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs();\n\t\tvar intersects = this._poly.newLatLngIntersects(latlngs[latlngs.length - 1]);\n\n\t\tif ((!this.options.allowIntersection && intersects) || !this._shapeIsValid()) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t// Called to verify the shape is valid when the user tries to finish it\n\t// Return false if the shape is not valid\n\t_shapeIsValid: function () {\n\t\treturn true;\n\t},\n\n\t_onZoomEnd: function () {\n\t\tif (this._markers !== null) {\n\t\t\tthis._updateGuide();\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar newPos = this._map.mouseEventToLayerPoint(e.originalEvent);\n\t\tvar latlng = this._map.layerPointToLatLng(newPos);\n\n\t\t// Save latlng\n\t\t// should this be moved to _updateGuide() ?\n\t\tthis._currentLatLng = latlng;\n\n\t\tthis._updateTooltip(latlng);\n\n\t\t// Update the guide line\n\t\tthis._updateGuide(newPos);\n\n\t\t// Update the mouse marker position\n\t\tthis._mouseMarker.setLatLng(latlng);\n\n\t\tL.DomEvent.preventDefault(e.originalEvent);\n\t},\n\n\t_vertexChanged: function (latlng, added) {\n\t\tthis._map.fire(L.Draw.Event.DRAWVERTEX, { layers: this._markerGroup });\n\t\tthis._updateFinishHandler();\n\n\t\tthis._updateRunningMeasure(latlng, added);\n\n\t\tthis._clearGuides();\n\n\t\tthis._updateTooltip();\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tif (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tthis._onMouseMove(e);\n\t\t\tthis._clickHandled = true;\n\t\t\tthis._disableNewMarkers();\n\t\t\tvar originalEvent = e.originalEvent;\n\t\t\tvar clientX = originalEvent.clientX;\n\t\t\tvar clientY = originalEvent.clientY;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t}\n\t},\n\n\t_startPoint: function (clientX, clientY) {\n\t\tthis._mouseDownOrigin = L.point(clientX, clientY);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX = originalEvent.clientX;\n\t\tvar clientY = originalEvent.clientY;\n\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\tthis._clickHandled = null;\n\t},\n\n\t_endPoint: function (clientX, clientY, e) {\n\t\tif (this._mouseDownOrigin) {\n\t\t\tvar dragCheckDistance = L.point(clientX, clientY)\n\t\t\t\t.distanceTo(this._mouseDownOrigin);\n\t\t\tvar lastPtDistance = this._calculateFinishDistance(e.latlng);\n\t\t\tif (lastPtDistance < 10 && L.Browser.touch) {\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (Math.abs(dragCheckDistance) < 9 * (window.devicePixelRatio || 1)) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t}\n\t\t\tthis._enableNewMarkers(); // after a short pause, enable new markers\n\t\t}\n\t\tthis._mouseDownOrigin = null;\n\t},\n\n\t// ontouch prevented by clickHandled flag because some browsers fire both click/touch events,\n\t// causing unwanted behavior\n\t_onTouch: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX;\n\t\tvar clientY;\n\t\tif (originalEvent.touches && originalEvent.touches[0] && !this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tclientX = originalEvent.touches[0].clientX;\n\t\t\tclientY = originalEvent.touches[0].clientY;\n\t\t\tthis._disableNewMarkers();\n\t\t\tthis._touchHandled = true;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\t\tthis._touchHandled = null;\n\t\t}\n\t\tthis._clickHandled = null;\n\t},\n\n\t_onMouseOut: function () {\n\t\tif (this._tooltip) {\n\t\t\tthis._tooltip._onMouseOut.call(this._tooltip);\n\t\t}\n\t},\n\n\t// calculate if we are currently within close enough distance\n\t// of the closing point (first point for shapes, last point for lines)\n\t// this is semi-ugly code but the only reliable way i found to get the job done\n\t// note: calculating point.distanceTo between mouseDownOrigin and last marker did NOT work\n\t_calculateFinishDistance: function (potentialLatLng) {\n\t\tvar lastPtDistance\n\t\tif (this._markers.length > 0) {\n\t\t\t\tvar finishMarker;\n\t\t\t\tif (this.type === L.Draw.Polyline.TYPE) {\n\t\t\t\t\tfinishMarker = this._markers[this._markers.length - 1];\n                } else if (this.type === L.Draw.Polygon.TYPE) {\n                    finishMarker = this._markers[0];\n                } else if (this.type === L.Draw.Cloud.TYPE) {\n                    finishMarker = this._markers[0];\n\t\t\t\t} else {\n\t\t\t\t\treturn Infinity;\n\t\t\t\t}\n\t\t\t\tvar lastMarkerPoint = this._map.latLngToContainerPoint(finishMarker.getLatLng()),\n\t\t\t\tpotentialMarker = new L.Marker(potentialLatLng, {\n\t\t\t\t\ticon: this.options.icon,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t\t\t});\n\t\t\t\tvar potentialMarkerPint = this._map.latLngToContainerPoint(potentialMarker.getLatLng());\n\t\t\t\tlastPtDistance = lastMarkerPoint.distanceTo(potentialMarkerPint);\n\t\t\t} else {\n\t\t\t\tlastPtDistance = Infinity;\n\t\t\t}\n\t\t\treturn lastPtDistance;\n\t},\n\n\t_updateFinishHandler: function () {\n\t\tvar markerCount = this._markers.length;\n\t\t// The last marker should have a click handler to close the polyline\n\t\tif (markerCount > 1) {\n\t\t\tthis._markers[markerCount - 1].on('click', this._finishShape, this);\n\t\t}\n\n\t\t// Remove the old marker click handler (as only the last point should close the polyline)\n\t\tif (markerCount > 2) {\n\t\t\tthis._markers[markerCount - 2].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng) {\n\t\tvar marker = new L.Marker(latlng, {\n\t\t\ticon: this.options.icon,\n\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t});\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_updateGuide: function (newPos) {\n\t\tvar markerCount = this._markers ? this._markers.length : 0;\n\n\t\tif (markerCount > 0) {\n\t\t\tnewPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);\n\n\t\t\t// draw the guide line\n\t\t\tthis._clearGuides();\n\t\t\tthis._drawGuide(\n\t\t\t\tthis._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()),\n\t\t\t\tnewPos\n\t\t\t);\n\t\t}\n\t},\n\n\t_updateTooltip: function (latLng) {\n\t\tvar text = this._getTooltipText();\n\n\t\tif (latLng) {\n\t\t\tthis._tooltip.updatePosition(latLng);\n\t\t}\n\n\t\tif (!this._errorShown) {\n\t\t\tthis._tooltip.updateContent(text);\n\t\t}\n\t},\n\n\t_drawGuide: function (pointA, pointB) {\n\t\tvar length = Math.floor(Math.sqrt(Math.pow((pointB.x - pointA.x), 2) + Math.pow((pointB.y - pointA.y), 2))),\n\t\t\tguidelineDistance = this.options.guidelineDistance,\n\t\t\tmaxGuideLineLength = this.options.maxGuideLineLength,\n\t\t\t// Only draw a guideline with a max length\n\t\t\ti = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,\n\t\t\tfraction,\n\t\t\tdashPoint,\n\t\t\tdash;\n\n\t\t//create the guides container if we haven't yet\n\t\tif (!this._guidesContainer) {\n\t\t\tthis._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);\n\t\t}\n\n\t\t//draw a dash every GuildeLineDistance\n\t\tfor (; i < length; i += this.options.guidelineDistance) {\n\t\t\t//work out fraction along line we are\n\t\t\tfraction = i / length;\n\n\t\t\t//calculate new x,y point\n\t\t\tdashPoint = {\n\t\t\t\tx: Math.floor((pointA.x * (1 - fraction)) + (fraction * pointB.x)),\n\t\t\t\ty: Math.floor((pointA.y * (1 - fraction)) + (fraction * pointB.y))\n\t\t\t};\n\n\t\t\t//add guide dash to guide container\n\t\t\tdash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);\n\t\t\tdash.style.backgroundColor =\n\t\t\t\t!this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;\n\n\t\t\tL.DomUtil.setPosition(dash, dashPoint);\n\t\t}\n\t},\n\n\t_updateGuideColor: function (color) {\n\t\tif (this._guidesContainer) {\n\t\t\tfor (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\n\t\t\t\tthis._guidesContainer.childNodes[i].style.backgroundColor = color;\n\t\t\t}\n\t\t}\n\t},\n\n\t// removes all child elements (guide dashes) from the guides container\n\t_clearGuides: function () {\n\t\tif (this._guidesContainer) {\n\t\t\twhile (this._guidesContainer.firstChild) {\n\t\t\t\tthis._guidesContainer.removeChild(this._guidesContainer.firstChild);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar showLength = this.options.showLength,\n\t\t\tlabelText, distanceStr;\n\t\tif (L.Browser.touch) {\n\t\t\tshowLength = false; // if there's a better place to put this, feel free to move it\n\t\t}\n\t\tif (this._markers.length === 0) {\n\t\t\tlabelText = {\n\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.start\n\t\t\t};\n\t\t} else {\n\t\t\tdistanceStr = showLength ? this._getMeasurementString() : '';\n\n\t\t\tif (this._markers.length === 1) {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.cont,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.end,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn labelText;\n\t},\n\n\t_updateRunningMeasure: function (latlng, added) {\n\t\tvar markersLength = this._markers.length,\n\t\t\tpreviousMarkerIndex, distance;\n\n\t\tif (this._markers.length === 1) {\n\t\t\tthis._measurementRunningTotal = 0;\n\t\t} else {\n\t\t\tpreviousMarkerIndex = markersLength - (added ? 2 : 1);\n\t\t\tdistance = this._map.distance(latlng, this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\n\t\t\tthis._measurementRunningTotal += distance * (added ? 1 : -1);\n\t\t}\n\t},\n\n\t_getMeasurementString: function () {\n\t\tvar currentLatLng = this._currentLatLng,\n\t\t\tpreviousLatLng = this._markers[this._markers.length - 1].getLatLng(),\n\t\t\tdistance;\n\n\t\t// calculate the distance from the last fixed point to the mouse position\n\t\tdistance = previousLatLng && currentLatLng ? this._measurementRunningTotal + this._map.distance(currentLatLng, previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0 ;\n\n\t\treturn L.GeometryUtil.readableDistance(distance, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);\n\t},\n\n\t_showErrorTooltip: function () {\n\t\tthis._errorShown = true;\n\n\t\t// Update tooltip\n\t\tthis._tooltip\n\t\t\t.showAsError()\n\t\t\t.updateContent({ text: this.options.drawError.message });\n\n\t\t// Update shape\n\t\tthis._updateGuideColor(this.options.drawError.color);\n\t\tthis._poly.setStyle({ color: this.options.drawError.color });\n\n\t\t// Hide the error after 2 seconds\n\t\tthis._clearHideErrorTimeout();\n\t\tthis._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\n\t},\n\n\t_hideErrorTooltip: function () {\n\t\tthis._errorShown = false;\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\t// Revert tooltip\n\t\tthis._tooltip\n\t\t\t.removeError()\n\t\t\t.updateContent(this._getTooltipText());\n\n\t\t// Revert shape\n\t\tthis._updateGuideColor(this.options.shapeOptions.color);\n\t\tthis._poly.setStyle({ color: this.options.shapeOptions.color });\n\t},\n\n\t_clearHideErrorTimeout: function () {\n\t\tif (this._hideErrorTimeout) {\n\t\t\tclearTimeout(this._hideErrorTimeout);\n\t\t\tthis._hideErrorTimeout = null;\n\t\t}\n\t},\n\n\t// disable new markers temporarily;\n\t// this is to prevent duplicated touch/click events in some browsers\n\t_disableNewMarkers: function () {\n\t\tthis._disableMarkers = true;\n\t},\n\n\t// see _disableNewMarkers\n\t_enableNewMarkers: function () {\n\t\tsetTimeout(function() {\n\t\t\tthis._disableMarkers = false;\n\t\t}.bind(this), 50);\n\t},\n\n\t_cleanUpShape: function () {\n\t\tif (this._markers.length > 1) {\n\t\t\tthis._markers[this._markers.length - 1].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\n\t}\n});\n","/**\r\n * @class L.Draw.Polygon\r\n * @aka Draw.Polygon\r\n * @inherits L.Draw.Polyline\r\n */\r\nL.Draw.Polygon = L.Draw.Polyline.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'polygon'\r\n\t},\r\n\r\n\tPoly: L.Polygon,\r\n\r\n\toptions: {\r\n\t\tshowArea: false,\r\n\t\tshowLength: false,\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\t// Whether to use the metric measurement system (truthy) or not (falsy).\r\n\t\t// Also defines the units to use for the metric system as an array of\r\n\t\t// strings (e.g. `['ha', 'm']`).\r\n\t\tmetric: true,\r\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\r\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\r\n\t\t// Defines the precision for each type of unit (e.g. {km: 2, ft: 0}\r\n\t\tprecision: {}\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Draw.Polyline.prototype.initialize.call(this, map, options);\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Polygon.TYPE;\r\n\t},\r\n\r\n\t_updateFinishHandler: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\r\n\t\t// The first marker should have a click handler to close the polygon\r\n\t\tif (markerCount === 1) {\r\n\t\t\tthis._markers[0].on('click', this._finishShape, this);\r\n\t\t}\r\n\r\n\t\t// Add and update the double click handler\r\n\t\tif (markerCount > 2) {\r\n\t\t\tthis._markers[markerCount - 1].on('dblclick', this._finishShape, this);\r\n\t\t\t// Only need to remove handler if has been added before\r\n\t\t\tif (markerCount > 3) {\r\n\t\t\t\tthis._markers[markerCount - 2].off('dblclick', this._finishShape, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar text, subtext;\r\n\r\n\t\tif (this._markers.length === 0) {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.start;\r\n\t\t} else if (this._markers.length < 3) {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.cont;\r\n\t\t\tsubtext = this._getMeasurementString();\r\n\t\t} else {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.end;\r\n\t\t\tsubtext = this._getMeasurementString();\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttext: text,\r\n\t\t\tsubtext: subtext\r\n\t\t};\r\n\t},\r\n\r\n\t_getMeasurementString: function () {\r\n\t\tvar area = this._area,\r\n\t\t\tmeasurementString = '';\r\n\r\n\r\n\t\tif (!area && !this.options.showLength) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (this.options.showLength) {\r\n\t\t\tmeasurementString = L.Draw.Polyline.prototype._getMeasurementString.call(this);\r\n\t\t}\r\n\r\n\t\tif (area) {\r\n\t\t\tmeasurementString += '<br>' + L.GeometryUtil.readableArea(area, this.options.metric, this.options.precision);\r\n\t\t}\r\n\r\n\t\treturn measurementString;\r\n\t},\r\n\r\n\t_shapeIsValid: function () {\r\n\t\treturn this._markers.length >= 3;\r\n\t},\r\n\r\n\t_vertexChanged: function (latlng, added) {\r\n\t\tvar latLngs;\r\n\r\n\t\t// Check to see if we should show the area\r\n\t\tif (!this.options.allowIntersection && this.options.showArea) {\r\n\t\t\tlatLngs = this._poly.getLatLngs();\r\n\r\n\t\t\tthis._area = L.GeometryUtil.geodesicArea(latLngs);\r\n\t\t}\r\n\r\n\t\tL.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);\r\n\t},\r\n\r\n\t_cleanUpShape: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\r\n\t\tif (markerCount > 0) {\r\n\t\t\tthis._markers[0].off('click', this._finishShape, this);\r\n\r\n\t\t\tif (markerCount > 2) {\r\n\t\t\t\tthis._markers[markerCount - 1].off('dblclick', this._finishShape, this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n","L.SimpleShape = {};\n/**\n * @class L.Draw.SimpleShape\n * @aka Draw.SimpleShape\n * @inherits L.Draw.Feature\n */\nL.Draw.SimpleShape = L.Draw.Feature.extend({\n\toptions: {\n\t\trepeatMode: false\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tthis._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._mapDraggable = this._map.dragging.enabled();\n\n\t\t\tif (this._mapDraggable) {\n\t\t\t\tthis._map.dragging.disable();\n\t\t\t}\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\n\t\t\tthis._tooltip.updateContent({ text: this._initialLabelText });\n\n\t\t\tthis._map\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('touchstart', this._onMouseDown, this)\n\t\t\t\t.on('touchmove', this._onMouseMove, this);\n\n            // we should prevent default, otherwise default behavior (scrolling) will fire,\n            // and that will cause document.touchend to fire and will stop the drawing\n            // (circle, rectangle) in touch mode.\n            // (update): we have to send passive now to prevent scroll, because by default it is {passive: true} now, which means,\n            // handler can't event.preventDefault\n            // check the news https://developers.google.com/web/updates/2016/06/passive-event-listeners\n            document.addEventListener('touchstart', L.DomEvent.preventDefault, {passive: false});\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\t\tif (this._map) {\n\t\t\tif (this._mapDraggable) {\n\t\t\t\tthis._map.dragging.enable();\n\t\t\t}\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = '';\n\n\t\t\tthis._map\n\t\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t\t.off('touchstart', this._onMouseDown, this)\n\t\t\t\t.off('touchmove', this._onMouseMove, this);\n\n\t\t\tL.DomEvent.off(document, 'mouseup', this._onMouseUp, this);\n\t\t\tL.DomEvent.off(document, 'touchend', this._onMouseUp, this);\n\n            document.removeEventListener('touchstart', L.DomEvent.preventDefault);\n\n\t\t\t// If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return\n\t\t\tif (this._shape) {\n\t\t\t\tthis._map.removeLayer(this._shape);\n\t\t\t\tdelete this._shape;\n\t\t\t}\n\t\t}\n\t\tthis._isDrawing = false;\n\t},\n\n\t_getTooltipText: function () {\n\t\treturn {\n\t\t\ttext: this._endLabelText\n\t\t};\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._isDrawing = true;\n\t\tthis._startLatLng = e.latlng;\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'mouseup', this._onMouseUp, this)\n\t\t\t.on(document, 'touchend', this._onMouseUp, this)\n\t\t\t.preventDefault(e.originalEvent);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tif (this._isDrawing) {\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\t\t\tthis._drawShape(latlng);\n\t\t}\n\t},\n\n\t_offMouseUpListeners: function() {\n        L.DomEvent\n            .off(document, 'mouseup', this._onMouseUp, this)\n            .off(document, 'touchend', this._onMouseUp, this);\n    },\n\n\t_onMouseUp: function () {\n\t\tthis._offMouseUpListeners();\n\n\t\tif (this._shape) {\n\t\t\tthis._fireCreatedEvent();\n\t\t}\n\n        this.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t}\n});","/**\r\n * @class L.Draw.Rectangle\r\n * @aka Draw.Rectangle\r\n * @inherits L.Draw.SimpleShape\r\n */\r\nL.Draw.Rectangle = L.Draw.SimpleShape.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'rectangle'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tshowArea: true,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\tmetric: true // Whether to use the metric measurement system or imperial\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Rectangle.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;\r\n\r\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t_drawShape: function (latlng) {\r\n\t\tif (!this._shape) {\r\n\t\t\tthis._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);\r\n\t\t\tthis._map.addLayer(this._shape);\r\n\t\t} else {\r\n\t\t\tthis._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\r\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar tooltipText = L.Draw.SimpleShape.prototype._getTooltipText.call(this),\r\n\t\t\tshape = this._shape,\r\n\t\t\tshowArea = this.options.showArea,\r\n\t\t\tlatLngs, area, subtext;\r\n\r\n\t\tif (shape) {\r\n\t\t\tlatLngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs();\r\n\t\t\tarea = L.GeometryUtil.geodesicArea(latLngs);\r\n\t\t\tsubtext = showArea ? L.GeometryUtil.readableArea(area, this.options.metric) : ''\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttext: tooltipText.text,\r\n\t\t\tsubtext: subtext\r\n\t\t};\r\n\t}\r\n});\r\n\r\nfunction _hasAncestor (el, cls) {\r\n\twhile ((el = el.parentElement) && !el.classList.contains(cls));\r\n\treturn el;\r\n}\r\n","/**\r\n * @class L.Draw.Marker\r\n * @aka Draw.Marker\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.Marker = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'marker'\r\n\t},\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\trepeatMode: false,\r\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Marker.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._tooltip.updateContent({ text: this._initialLabelText });\r\n\r\n\t\t\t// Same mouseMarker as in Draw.Polyline\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40]\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker\r\n\t\t\t\t.on('click', this._onClick, this)\r\n\t\t\t\t.addTo(this._map);\r\n\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click', this._onTouch, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tif (this._marker) {\r\n\t\t\t\tthis._marker.off('click', this._onClick, this);\r\n\t\t\t\tthis._map\r\n\t\t\t\t\t.off('click', this._onClick, this)\r\n\t\t\t\t\t.off('click', this._onTouch, this)\r\n\t\t\t\t\t.removeLayer(this._marker);\r\n\t\t\t\tdelete this._marker;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.off('click', this._onClick, this);\r\n\t\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\t\tdelete this._mouseMarker;\r\n\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tif (!this._marker) {\r\n\t\t\tthis._marker = this._createMarker(latlng);\r\n\t\t\t// Bind to both marker and map to make sure we get the click event.\r\n\t\t\tthis._marker.on('click', this._onClick, this);\r\n\t\t\tthis._map\r\n\t\t\t\t.on('click', this._onClick, this)\r\n\t\t\t\t.addLayer(this._marker);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlatlng = this._mouseMarker.getLatLng();\r\n\t\t\tthis._marker.setLatLng(latlng);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\treturn new L.Marker(latlng, {\r\n\t\t\ticon: this.options.icon,\r\n\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t});\r\n\t},\r\n\r\n\t_onClick: function () {\r\n\t\tthis._fireCreatedEvent();\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onTouch: function (e) {\r\n\t\t// called on click & tap, only really does any thing on tap\r\n\t\tthis._onMouseMove(e); // creates & places marker\r\n\t\tthis._onClick(); // permanently places marker & ends interaction\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar marker = new L.Marker.Touch(this._marker.getLatLng(), { icon: this.options.icon });\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.CircleMarker\r\n * @aka Draw.CircleMarker\r\n * @inherits L.Draw.Marker\r\n */\r\nL.Draw.CircleMarker = L.Draw.Marker.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'circlemarker'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#3388ff',\r\n\t\tweight: 4,\r\n\t\topacity: 0.5,\r\n\t\tfill: true,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\t\tclickable: true,\r\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.CircleMarker.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar circleMarker = new L.CircleMarker(this._marker.getLatLng(), this.options);\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, circleMarker);\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\treturn new L.CircleMarker(latlng, this.options);\r\n\t}\r\n});\r\n","/**\n * @class L.Draw.Circle\n * @aka Draw.Circle\n * @inherits L.Draw.SimpleShape\n */\nL.Draw.Circle = L.Draw.SimpleShape.extend({\n\tstatics: {\n\t\tTYPE: 'circle'\n\t},\n\n\toptions: {\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\tshowRadius: true,\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, use feet instead of yards for display\n\t\tnautic: false // When not metric, not feet use nautic mile for display\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Circle.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;\n\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n\t},\n\n\t_drawShape: function (latlng) {\n    var distance = this._map.distance(this._startLatLng, latlng);\n\t\tif (!this._shape) {\n\t\t\tthis._shape = new L.Circle(this._startLatLng, distance, this.options.shapeOptions);\n\t\t\tthis._map.addLayer(this._shape);\n\t\t} else {\n\t\t\tthis._shape.setRadius(distance);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng,\n\t\t\tshowRadius = this.options.showRadius,\n\t\t\tuseMetric = this.options.metric,\n\t\t\tradius;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tif (this._isDrawing) {\n\t\t\tthis._drawShape(latlng);\n\n\t\t\t// Get the new radius (rounded to 1 dp)\n\t\t\tradius = this._shape.getRadius().toFixed(1);\n\n\t\t\tvar subtext = '';\n\t\t\tif (showRadius) {\n\t\t\t\tsubtext = L.drawLocal.draw.handlers.circle.radius + ': ' +\n\t\t\t\t\t\t  L.GeometryUtil.readableDistance(radius, useMetric, this.options.feet, this.options.nautic);\n\t\t\t}\n\t\t\tthis._tooltip.updateContent({\n\t\t\t\ttext: this._endLabelText,\n\t\t\t\tsubtext: subtext\n\t\t\t});\n\t\t}\n\t}\n});\n","L.Util.Random = function(seed) {\n    this._seed = seed % 2147483647;\n    if (this._seed <= 0) this._seed += 2147483646;\n};\n\n/**\n * Returns a pseudo-random value between 1 and 2^32 - 2.\n */\nL.Util.Random.prototype.next = function () {\n    return this._seed = this._seed * 16807 % 2147483647;\n};\n\n\n/**\n * Returns a pseudo-random floating point number in range [0, 1).\n */\nL.Util.Random.prototype.nextFloat = function () {\n    // We know that result of next() will be 1 to 2147483646 (inclusive).\n    return (this.next() - 1) / 2147483646;\n};\n\nL.Cloud = L.Polygon.extend({\n    options: {\n        frillLen: 50.0,\n        frillHeight: .6,\n        fillRule: 'nonzero'\n    },\n\n    _polygonArea: function(vertices) {\n        var area = 0;\n        for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            area += vertices[i].x * vertices[j].y;\n            area -= vertices[j].x * vertices[i].y;\n        }\n        return area;\n    },\n\n    _updatePath: function () {\n        var rings = this._parts;\n\n        var path = '',\n            i, j, rn, len2, points, p,\n        frillLen = this.options.frillLen,\n        frillHeight = this.options.frillHeight;\n        var rand = new L.Util.Random(3);\n        var minFrillLen = 0.1;\n\n        for (i = 0, rn = rings.length; i < rn; i++) {\n            points = rings[i];\n\n            var prevP;\n            var sign = this._polygonArea(points) < 0 ? -1 : 1;\n            len2 = points.length;\n            for (j = 0; j <= len2; j++) {\n                p = points[j % len2];\n                if(j) {\n                    var dx = p.x - prevP.x;\n                    var dy = p.y - prevP.y;\n                    var len = Math.sqrt(dx * dx + dy * dy);\n                    if(len < minFrillLen) {\n                        path += 'l' + dx + ' ' + dy;\n                    } else {\n                        // Scaled normal vector\n                        var n = Math.max(Math.floor(len / frillLen + .5), 1);\n                        // Scaled directional vector\n                        var flen = len / n;\n                        // Normalized directional vector\n                        dx /= len;\n                        dy /= len;\n                        var ix = flen * dx;\n                        var iy = flen * dy;\n                        var nx = iy * frillHeight * sign;\n                        var ny = -ix * frillHeight * sign;\n                        for(; n; n--) {\n                            var r1 = 0.5 + rand.nextFloat();\n                            var r2 = 0.5 + rand.nextFloat();\n                            path += 'c' + r1 * nx + ' ' + r1 * ny + ',' + (ix + r2 * nx) + ' ' + (iy + r2 * ny) + ',' + ix + ' ' + iy;\n                        }\n                    }\n                } else {\n                    path += 'M' + p.x + ' ' + p.y;\n                }\n                prevP = p;\n            }\n            // path += 'z';\n        }\n\n        this._path.setAttribute('d', path || 'M0 0');\n    }\n});\n\nL.Draw.Cloud = L.Draw.Polygon.extend({\n    statics: {\n        TYPE: 'cloud'\n    },\n\n    Poly: L.Cloud,\n\n    initialize: function (map, options) {\n        L.Draw.Polygon.prototype.initialize.call(this, map, options);\n        this.type = L.Draw.Cloud.TYPE;\n    }\n});\n\nL.cloud = function(latlngs, options) {\n    return new L.Cloud(latlngs, options);\n}","L.Arrow = L.Polygon.extend({\n    /*        (1)                ---\n              /|               athickness%\n             / |(2)         (3)   |\n            /  |--------------   ---\n           /                 | thickness%\n         (X) . . . LEN . . . O   ---\n           \\                 |\n            \\  |--------------\n             \\ |(5)         (4)\n              \\|\n              (6)\n               |---length%---|\n     */\n    options: {\n        noClip: true,\n        /**\n         * Nyilhegy kilógó szélessége törzs vastagság %-ban\n         */\n        athickness: .9,\n\n        fill: true,\n        fillColor: null, //same as color by default\n        fillOpacity: 0.2\n    },\n\n    _updatePath: function () {\n        var rings = this._parts;\n\n        var path, i, j, points, rn;\n\n        for (i = 0, rn = rings.length; i < rn; i++) {\n            points = rings[i];\n\n            // Arrow head\n            var p1 = points[0];\n            var p2 = points[1];\n            var p3 = points[2];\n            path = 'M' + p2.x + ' ' + p2.y;\n\n            if(p3) {\n                var dx = p2.x - p1.x;\n                var dy = p2.y - p1.y;\n\n                var l = Math.sqrt(dx * dx + dy * dy);\n\n                if (l < 0.001) continue;\n\n                var ix = dx / l;\n                var iy = dy / l;\n\n                if (p3) {\n                    var d3x = p3.x - p1.x;\n                    var d3y = p3.y - p1.y;\n                    // Főirányba eső hossz %-ban\n                    len = Math.abs(d3x * ix + d3y * iy) / l;\n                    // Merőleges irány hossz %-ban\n                    var th = Math.abs(-d3x * iy + d3y * ix) / l;\n                    var ath = this.options.athickness * th;\n\n                    var relpts = [\n                        len - 1.0, ath + th,\n                        0, -ath,\n                        -len, 0,\n                        0, -2 * th,\n                        len, 0,\n                        0, -ath\n                    ];\n\n                    for (j = 0; j < relpts.length; j += 2) {\n                        x = relpts[j];\n                        y = relpts[j + 1];\n                        path += 'l' + (x * dx - y * dy) + ' ' + (x * dy + y * dx);\n                    }\n                }\n            }\n\n            path += 'z';\n        }\n\n        this._path.setAttribute('d', path || 'M0 0');\n    }\n});\n\nL.Draw.Arrow = L.Draw.Polygon.extend({\n    statics: {\n        TYPE: 'arrow',\n        /**\n         * Törzs vastagsága LEN%-ban\n         */\n        THICKNESS: .1,\n        /**\n         * Törzs hossza LEN%-ban\n         */\n        LENGTH: .8,\n    },\n\n    Poly: L.Arrow,\n\n    initialize: function (map, options) {\n        L.Draw.Polygon.prototype.initialize.call(this, map, options);\n        this.type = L.Draw.Arrow.TYPE;\n    },\n\n    _addControlPoint: function () {\n        // Arrow head\n        var p1 = this._markers[0]._latlng;\n        var p2 = this._markers[1]._latlng;\n        var dLng = p2.lng - p1.lng;\n        var dLat = p2.lat - p1.lat;\n\n        var th = L.Draw.Arrow.THICKNESS;\n        var len = L.Draw.Arrow.LENGTH;\n        this.addVertex({\n            lng: p1.lng + dLng * len - dLat * th,\n            lat: p1.lat + dLat * len + dLng * th\n        });\n    },\n\n    _endPoint: function (clientX, clientY, e) {\n        L.Draw.Polygon.prototype._endPoint.call(this, clientX, clientY, e);\n        if(this._markers.length == 2) {\n            this._addControlPoint();\n            this._finishShape();\n        }\n    }\n});\n\nL.arrow = function(latlngs, options) {\n    return new L.Arrow(latlngs, options);\n};","L.Edit = L.Edit || {};\r\n\r\n/**\r\n * @class L.Edit.Marker\r\n * @aka Edit.Marker\r\n */\r\nL.Edit.Marker = L.Handler.extend({\r\n\t// @method initialize(): void\r\n\tinitialize: function (marker, options) {\r\n\t\tthis._marker = marker;\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar marker = this._marker;\r\n\r\n\t\tmarker.dragging.enable();\r\n\t\tmarker.on('dragend', this._onDragEnd, marker);\r\n\t\tthis._toggleMarkerHighlight();\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tvar marker = this._marker;\r\n\r\n\t\tmarker.dragging.disable();\r\n\t\tmarker.off('dragend', this._onDragEnd, marker);\r\n\t\tthis._toggleMarkerHighlight();\r\n\t},\r\n\r\n\t_onDragEnd: function (e) {\r\n\t\tvar layer = e.target;\r\n\t\tlayer.edited = true;\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: layer });\r\n\t},\r\n\r\n\t_toggleMarkerHighlight: function () {\r\n\t\tvar icon = this._marker._icon;\r\n\r\n\t\t// Don't do anything if this layer is a marker but doesn't have an icon. Markers\r\n\t\t// should usually have icons. If using Leaflet.draw with Leaflet.markercluster there\r\n\t\t// is a chance that a marker doesn't.\r\n\t\tif (!icon) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)\r\n\t\ticon.style.display = 'none';\r\n\r\n\t\tif (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {\r\n\t\t\tL.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected');\r\n\t\t\t// Offset as the border will make the icon move.\r\n\t\t\tthis._offsetMarker(icon, -4);\r\n\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(icon, 'leaflet-edit-marker-selected');\r\n\t\t\t// Offset as the border will make the icon move.\r\n\t\t\tthis._offsetMarker(icon, 4);\r\n\t\t}\r\n\r\n\t\ticon.style.display = '';\r\n\t},\r\n\r\n\t_offsetMarker: function (icon, offset) {\r\n\t\tvar iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,\r\n\t\t\ticonMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;\r\n\r\n\t\ticon.style.marginTop = iconMarginTop + 'px';\r\n\t\ticon.style.marginLeft = iconMarginLeft + 'px';\r\n\t}\r\n});\r\n\r\nL.Marker.addInitHook(function () {\r\n\tif (L.Edit.Marker) {\r\n\t\tthis.editing = new L.Edit.Marker(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\n\n/**\n * @class L.Edit.Polyline\n * @aka L.Edit.Poly\n * @aka Edit.Poly\n */\nL.Edit.Poly = L.Handler.extend({\n\toptions: {},\n\n\t// @method initialize(): void\n\tinitialize: function (poly, options) {\n\n\t\tthis.latlngs = [poly._latlngs];\n\t\tif (poly._holes) {\n\t\t\tthis.latlngs = this.latlngs.concat(poly._holes);\n\t\t}\n\n\t\tthis._poly = poly;\n\t\tL.setOptions(this, options);\n\n\t\tthis._poly.on('revert-edited', this._updateLatLngs, this);\n\t},\n\n\t// Compatibility method to normalize Poly* objects\n\t// between 0.7.x and 1.0+\n\t_defaultShape: function () {\n\t\tif (!L.Polyline._flat) {\n\t\t\treturn this._poly._latlngs;\n\t\t}\n\t\treturn L.Polyline._flat(this._poly._latlngs) ? this._poly._latlngs : this._poly._latlngs[0];\n\t},\n\n\t_eachVertexHandler: function (callback) {\n\t\tfor (var i = 0; i < this._verticesHandlers.length; i++) {\n\t\t\tcallback(this._verticesHandlers[i]);\n\t\t}\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tthis._initHandlers();\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.addHooks();\n\t\t});\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.removeHooks();\n\t\t});\n\t},\n\n\t// @method updateMarkers(): void\n\t// Fire an update for each vertex handler\n\tupdateMarkers: function () {\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.updateMarkers();\n\t\t});\n\t},\n\n\t_initHandlers: function () {\n\t\tthis._verticesHandlers = [];\n\t\tfor (var i = 0; i < this.latlngs.length; i++) {\n\t\t\tthis._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly, this.latlngs[i], this.options));\n\t\t}\n\t},\n\n\t_updateLatLngs: function (e) {\n\t\tthis.latlngs = [e.layer._latlngs];\n\t\tif (e.layer._holes) {\n\t\t\tthis.latlngs = this.latlngs.concat(e.layer._holes);\n\t\t}\n\t}\n\n});\n\n/**\n * @class L.Edit.PolyVerticesEdit\n * @aka Edit.PolyVerticesEdit\n */\nL.Edit.PolyVerticesEdit = L.Handler.extend({\n\toptions: {\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 1000\n\t\t}\n\n\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (poly, latlngs, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\t\tthis._poly = poly;\n\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\tthis._latlngs = latlngs;\n\n\t\tL.setOptions(this, options);\n\t},\n\n\t// Compatibility method to normalize Poly* objects\n\t// between 0.7.x and 1.0+\n\t_defaultShape: function () {\n\t\tif (!L.Polyline._flat) {\n\t\t\treturn this._latlngs;\n\t\t}\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tvar poly = this._poly;\n\n\t\tif (!(poly instanceof L.Polygon)) {\n\t\t\tpoly.options.fill = false;\n\t\t\tif (poly.options.editing) {\n\t\t\t\tpoly.options.editing.fill = false;\n\t\t\t}\n\t\t}\n\n\t\tpoly.setStyle(poly.options.editing);\n\n\t\tif (this._poly._map) {\n\n\t\t\tthis._map = this._poly._map; // Set map\n\n\t\t\tif (!this._markerGroup) {\n\t\t\t\tthis._initMarkers();\n\t\t\t}\n\t\t\tthis._poly._map.addLayer(this._markerGroup);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tvar poly = this._poly;\n\n\t\tpoly.setStyle(poly.options.original);\n\n\t\tif (poly._map) {\n\t\t\tpoly._map.removeLayer(this._markerGroup);\n\t\t\tdelete this._markerGroup;\n\t\t\tdelete this._markers;\n\t\t}\n\t},\n\n\t// @method updateMarkers(): void\n\t// Clear markers and update their location\n\tupdateMarkers: function () {\n\t\tthis._markerGroup.clearLayers();\n\t\tthis._initMarkers();\n\t},\n\n\t_initMarkers: function () {\n\t\tif (!this._markerGroup) {\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t}\n\t\tthis._markers = [];\n\n\t\tvar latlngs = this._defaultShape(),\n\t\t\ti, j, len, marker;\n\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\n\n\t\t\tmarker = this._createMarker(latlngs[i], i);\n\t\t\tmarker.on('click', this._onMarkerClick, this);\n\t\t\tthis._markers.push(marker);\n\t\t}\n\n\t\tvar markerLeft, markerRight;\n\n        if(!(L.Arrow && this._poly instanceof L.Arrow)) {\n            for (i = 0, j = len - 1; i < len; j = i++) {\n                if (i === 0 && !(L.Polygon && (this._poly instanceof L.Polygon))) {\n                    continue;\n                }\n\n                markerLeft = this._markers[j];\n                markerRight = this._markers[i];\n\n                this._createMiddleMarker(markerLeft, markerRight);\n                this._updatePrevNext(markerLeft, markerRight);\n            }\n\t\t}\n\t},\n\n\t_createMarker: function (latlng, index) {\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\n\t\tvar marker = new L.Marker.Touch(latlng, {\n\t\t\tdraggable: true,\n\t\t\ticon: this.options.icon,\n\t\t});\n\n\t\tmarker._origLatLng = latlng;\n\t\tmarker._index = index;\n\n\t\tmarker\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\n\t\t\t.on('drag', this._onMarkerDrag, this)\n\t\t\t.on('dragend', this._fireEdit, this)\n\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t.on('touchend', this._fireEdit, this)\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t.on('MSPointerUp', this._fireEdit, this);\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_onMarkerDragStart: function () {\n\t\tthis._poly.fire('editstart');\n\t},\n\n\t_spliceLatLngs: function () {\n\t\tvar latlngs = this._defaultShape();\n\t\tvar removed = [].splice.apply(latlngs, arguments);\n\t\tthis._poly._convertLatLngs(latlngs, true);\n\t\tthis._poly.redraw();\n\t\treturn removed;\n\t},\n\n\t_removeMarker: function (marker) {\n\t\tvar i = marker._index;\n\n\t\tthis._markerGroup.removeLayer(marker);\n\t\tthis._markers.splice(i, 1);\n\t\tthis._spliceLatLngs(i, 1);\n\t\tthis._updateIndexes(i, -1);\n\n\t\tmarker\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\n\t\t\t.off('drag', this._onMarkerDrag, this)\n\t\t\t.off('dragend', this._fireEdit, this)\n\t\t\t.off('touchmove', this._onMarkerDrag, this)\n\t\t\t.off('touchend', this._fireEdit, this)\n\t\t\t.off('click', this._onMarkerClick, this)\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t.off('MSPointerUp', this._fireEdit, this);\n\t},\n\n\t_fireEdit: function () {\n\t\tthis._poly.edited = true;\n\t\tthis._poly.fire('edit');\n\t\tthis._poly._map.fire(L.Draw.Event.EDITVERTEX, { layers: this._markerGroup, poly: this._poly });\n\t},\n\n\t_onMarkerDrag: function (e) {\n\t\tvar marker = e.target;\n\t\tvar poly = this._poly;\n\n\t\tL.extend(marker._origLatLng, marker._latlng);\n\n\t\tif (marker._middleLeft) {\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n\t\t}\n\n\t\tif (poly.options.poly) {\n\t\t\tvar tooltip = poly._map._editTooltip; // Access the tooltip\n\n\t\t\t// If we don't allow intersections and the polygon intersects\n\t\t\tif (!poly.options.poly.allowIntersection && poly.intersects()) {\n\n\t\t\t\tvar originalColor = poly.options.color;\n\t\t\t\tpoly.setStyle({ color: this.options.drawError.color });\n\n\t\t\t\t// Manually trigger 'dragend' behavior on marker we are about to remove\n\t\t\t\t// WORKAROUND: introduced in 1.0.0-rc2, may be related to #4484\n\t\t\t\tif (L.version.indexOf('0.7') !== 0) {\n\t\t\t\t\tmarker.dragging._draggable._onUp(e);\n\t\t\t\t}\n\t\t\t\tthis._onMarkerClick(e); // Remove violating marker\n\t\t\t\t// FIXME: Reset the marker to it's original position (instead of remove)\n\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.updateContent({\n\t\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.error\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Reset everything back to normal after a second\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tpoly.setStyle({ color: originalColor });\n\t\t\t\t\tif (tooltip) {\n\t\t\t\t\t\ttooltip.updateContent({\n\t\t\t\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}\n\n\t\tthis._poly.redraw();\n\t\tthis._poly.fire('editdrag');\n\t},\n\n\t_onMarkerClick: function (e) {\n\n\t\tvar minPoints = L.Polygon && (this._poly instanceof L.Polygon) ? 4 : 3,\n\t\t\tmarker = e.target;\n\n\t\t// If removing this point would create an invalid polyline/polygon don't remove\n\t\tif (this._defaultShape().length < minPoints) {\n\t\t\treturn;\n\t\t}\n\n\t\t// remove the marker\n\t\tthis._removeMarker(marker);\n\n\t\t// update prev/next links of adjacent markers\n\t\tthis._updatePrevNext(marker._prev, marker._next);\n\n\t\t// remove ghost markers near the removed marker\n\t\tif (marker._middleLeft) {\n\t\t\tthis._markerGroup.removeLayer(marker._middleLeft);\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tthis._markerGroup.removeLayer(marker._middleRight);\n\t\t}\n\n\t\t// create a ghost marker in place of the removed one\n\t\tif (marker._prev && marker._next) {\n\t\t\tthis._createMiddleMarker(marker._prev, marker._next);\n\n\t\t} else if (!marker._prev) {\n\t\t\tmarker._next._middleLeft = null;\n\n\t\t} else if (!marker._next) {\n\t\t\tmarker._prev._middleRight = null;\n\t\t}\n\n\t\tthis._fireEdit();\n\t},\n\n\t_onTouchMove: function (e) {\n\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\n\t\t\tmarker = e.target;\n\n\t\tL.extend(marker._origLatLng, latlng);\n\n\t\tif (marker._middleLeft) {\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n\t\t}\n\n\t\tthis._poly.redraw();\n\t\tthis.updateMarkers();\n\t},\n\n\t_updateIndexes: function (index, delta) {\n\t\tthis._markerGroup.eachLayer(function (marker) {\n\t\t\tif (marker._index > index) {\n\t\t\t\tmarker._index += delta;\n\t\t\t}\n\t\t});\n\t},\n\n\t_createMiddleMarker: function (marker1, marker2) {\n\t\tvar latlng = this._getMiddleLatLng(marker1, marker2),\n\t\t\tmarker = this._createMarker(latlng),\n\t\t\tonClick,\n\t\t\tonDragStart,\n\t\t\tonDragEnd;\n\n\t\tmarker.setOpacity(0.6);\n\n\t\tmarker1._middleRight = marker2._middleLeft = marker;\n\n\t\tonDragStart = function () {\n\t\t\tmarker.off('touchmove', onDragStart, this);\n\t\t\tvar i = marker2._index;\n\n\t\t\tmarker._index = i;\n\n\t\t\tmarker\n\t\t\t\t.off('click', onClick, this)\n\t\t\t\t.on('click', this._onMarkerClick, this);\n\n\t\t\tlatlng.lat = marker.getLatLng().lat;\n\t\t\tlatlng.lng = marker.getLatLng().lng;\n\t\t\tthis._spliceLatLngs(i, 0, latlng);\n\t\t\tthis._markers.splice(i, 0, marker);\n\n\t\t\tmarker.setOpacity(1);\n\n\t\t\tthis._updateIndexes(i, 1);\n\t\t\tmarker2._index++;\n\t\t\tthis._updatePrevNext(marker1, marker);\n\t\t\tthis._updatePrevNext(marker, marker2);\n\n\t\t\tthis._poly.fire('editstart');\n\t\t};\n\n\t\tonDragEnd = function () {\n\t\t\tmarker.off('dragstart', onDragStart, this);\n\t\t\tmarker.off('dragend', onDragEnd, this);\n\t\t\tmarker.off('touchmove', onDragStart, this);\n\n\t\t\tthis._createMiddleMarker(marker1, marker);\n\t\t\tthis._createMiddleMarker(marker, marker2);\n\t\t};\n\n\t\tonClick = function () {\n\t\t\tonDragStart.call(this);\n\t\t\tonDragEnd.call(this);\n\t\t\tthis._fireEdit();\n\t\t};\n\n\t\tmarker\n\t\t\t.on('click', onClick, this)\n\t\t\t.on('dragstart', onDragStart, this)\n\t\t\t.on('dragend', onDragEnd, this)\n\t\t\t.on('touchmove', onDragStart, this);\n\n\t\tthis._markerGroup.addLayer(marker);\n\t},\n\n\t_updatePrevNext: function (marker1, marker2) {\n\t\tif (marker1) {\n\t\t\tmarker1._next = marker2;\n\t\t}\n\t\tif (marker2) {\n\t\t\tmarker2._prev = marker1;\n\t\t}\n\t},\n\n\t_getMiddleLatLng: function (marker1, marker2) {\n\t\tvar map = this._poly._map,\n\t\t\tp1 = map.project(marker1.getLatLng()),\n\t\t\tp2 = map.project(marker2.getLatLng());\n\n\t\treturn map.unproject(p1._add(p2)._divideBy(2));\n\t}\n});\n\nL.Polyline.addInitHook(function () {\n\n\t// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\n\tif (this.editing) {\n\t\treturn;\n\t}\n\n\tif (L.Edit.Poly) {\n\n\t\tthis.editing = new L.Edit.Poly(this, this.options.poly);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n\n\tthis.on('add', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.addHooks();\n\t\t}\n\t});\n\n\tthis.on('remove', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.removeHooks();\n\t\t}\n\t});\n});\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.SimpleShape\r\n * @aka Edit.SimpleShape\r\n */\r\nL.Edit.SimpleShape = L.Handler.extend({\r\n\toptions: {\r\n\t\tmoveIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move'\r\n\t\t}),\r\n\t\tresizeIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize'\r\n\t\t}),\r\n\t\ttouchMoveIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon'\r\n\t\t}),\r\n\t\ttouchResizeIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon'\r\n\t\t}),\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (shape, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.moveIcon = this.options.touchMoveIcon;\r\n\t\t\tthis.options.resizeIcon = this.options.touchResizeIcon;\r\n\t\t}\r\n\r\n\t\tthis._shape = shape;\r\n\t\tL.Util.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar shape = this._shape;\r\n\t\tif (this._shape._map) {\r\n\t\t\tthis._map = this._shape._map;\r\n\t\t\tshape.setStyle(shape.options.editing);\r\n\r\n\t\t\tif (shape._map) {\r\n\t\t\t\tthis._map = shape._map;\r\n\t\t\t\tif (!this._markerGroup) {\r\n\t\t\t\t\tthis._initMarkers();\r\n\t\t\t\t}\r\n\t\t\t\tthis._map.addLayer(this._markerGroup);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tvar shape = this._shape;\r\n\r\n\t\tshape.setStyle(shape.options.original);\r\n\r\n\t\tif (shape._map) {\r\n\t\t\tthis._unbindMarker(this._moveMarker);\r\n\r\n\t\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\t\tthis._unbindMarker(this._resizeMarkers[i]);\r\n\t\t\t}\r\n\t\t\tthis._resizeMarkers = null;\r\n\r\n\t\t\tthis._map.removeLayer(this._markerGroup);\r\n\t\t\tdelete this._markerGroup;\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Remove the edit markers from this layer\r\n\tupdateMarkers: function () {\r\n\t\tthis._markerGroup.clearLayers();\r\n\t\tthis._initMarkers();\r\n\t},\r\n\r\n\t_initMarkers: function () {\r\n\t\tif (!this._markerGroup) {\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t}\r\n\r\n\t\t// Create center marker\r\n\t\tthis._createMoveMarker();\r\n\r\n\t\t// Create edge marker\r\n\t\tthis._createResizeMarker();\r\n\t},\r\n\r\n\t_createMoveMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createMarker: function (latlng, icon) {\r\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\r\n\t\tvar marker = new L.Marker.Touch(latlng, {\r\n\t\t\tdraggable: true,\r\n\t\t\ticon: icon,\r\n\t\t\tzIndexOffset: 10\r\n\t\t});\r\n\r\n\t\tthis._bindMarker(marker);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_bindMarker: function (marker) {\r\n\t\tmarker\r\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\r\n\t\t\t.on('drag', this._onMarkerDrag, this)\r\n\t\t\t.on('dragend', this._onMarkerDragEnd, this)\r\n\t\t\t.on('touchstart', this._onTouchStart, this)\r\n\t\t\t.on('touchmove', this._onTouchMove, this)\r\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t.on('touchend', this._onTouchEnd, this)\r\n\t\t\t.on('MSPointerUp', this._onTouchEnd, this);\r\n\t},\r\n\r\n\t_unbindMarker: function (marker) {\r\n\t\tmarker\r\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\r\n\t\t\t.off('drag', this._onMarkerDrag, this)\r\n\t\t\t.off('dragend', this._onMarkerDragEnd, this)\r\n\t\t\t.off('touchstart', this._onTouchStart, this)\r\n\t\t\t.off('touchmove', this._onTouchMove, this)\r\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t.off('touchend', this._onTouchEnd, this)\r\n\t\t\t.off('MSPointerUp', this._onTouchEnd, this);\r\n\t},\r\n\r\n\t_onMarkerDragStart: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(0);\r\n\r\n\t\tthis._shape.fire('editstart');\r\n\t},\r\n\r\n\t_fireEdit: function () {\r\n\t\tthis._shape.edited = true;\r\n\t\tthis._shape.fire('edit');\r\n\t},\r\n\r\n\t_onMarkerDrag: function (e) {\r\n\t\tvar marker = e.target,\r\n\t\t\tlatlng = marker.getLatLng();\r\n\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tthis._move(latlng);\r\n\t\t} else {\r\n\t\t\tthis._resize(latlng);\r\n\t\t}\r\n\r\n\t\tthis._shape.redraw();\r\n\t\tthis._shape.fire('editdrag');\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(1);\r\n\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_onTouchStart: function (e) {\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\r\n\r\n\t\tif (typeof(this._getCorners) === 'function') {\r\n\t\t\t// Save a reference to the opposite point\r\n\t\t\tvar corners = this._getCorners(),\r\n\t\t\t\tmarker = e.target,\r\n\t\t\t\tcurrentCornerIndex = marker._cornerIndex;\r\n\r\n\t\t\tmarker.setOpacity(0);\r\n\r\n\t\t\t// Copyed from Edit.Rectangle.js line 23 _onMarkerDragStart()\r\n\t\t\t// Latlng is null otherwise.\r\n\t\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\r\n\t\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\r\n\t\t}\r\n\r\n\t\tthis._shape.fire('editstart');\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\r\n\t\t\tmarker = e.target;\r\n\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tthis._move(latlng);\r\n\t\t} else {\r\n\t\t\tthis._resize(latlng);\r\n\t\t}\r\n\r\n\t\tthis._shape.redraw();\r\n\r\n\t\t// prevent touchcancel in IOS\r\n\t\t// e.preventDefault();\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_onTouchEnd: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(1);\r\n\t\tthis.updateMarkers();\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_move: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_resize: function () {\r\n\t\t// Children override\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.Rectangle\r\n * @aka Edit.Rectangle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.Rectangle = L.Edit.SimpleShape.extend({\r\n\t_createMoveMarker: function () {\r\n\t\tvar bounds = this._shape.getBounds(),\r\n\t\t\tcenter = bounds.getCenter();\r\n\r\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\tvar corners = this._getCorners();\r\n\r\n\t\tthis._resizeMarkers = [];\r\n\r\n\t\tfor (var i = 0, l = corners.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));\r\n\t\t\t// Monkey in the corner index as we will need to know this for dragging\r\n\t\t\tthis._resizeMarkers[i]._cornerIndex = i;\r\n\t\t}\r\n\t},\r\n\r\n\t_onMarkerDragStart: function (e) {\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\r\n\r\n\t\t// Save a reference to the opposite point\r\n\t\tvar corners = this._getCorners(),\r\n\t\t\tmarker = e.target,\r\n\t\t\tcurrentCornerIndex = marker._cornerIndex;\r\n\r\n\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\r\n\r\n\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar marker = e.target,\r\n\t\t\tbounds, center;\r\n\r\n\t\t// Reset move marker position to the center\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tbounds = this._shape.getBounds();\r\n\t\t\tcenter = bounds.getCenter();\r\n\r\n\t\t\tmarker.setLatLng(center);\r\n\t\t}\r\n\r\n\t\tthis._toggleCornerMarkers(1);\r\n\r\n\t\tthis._repositionCornerMarkers();\r\n\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);\r\n\t},\r\n\r\n\t_move: function (newCenter) {\r\n\t\tvar latlngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(),\r\n\t\t\tbounds = this._shape.getBounds(),\r\n\t\t\tcenter = bounds.getCenter(),\r\n\t\t\toffset, newLatLngs = [];\r\n\r\n\t\t// Offset the latlngs to the new center\r\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\r\n\t\t\toffset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];\r\n\t\t\tnewLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);\r\n\t\t}\r\n\r\n\t\tthis._shape.setLatLngs(newLatLngs);\r\n\r\n\t\t// Reposition the resize markers\r\n\t\tthis._repositionCornerMarkers();\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tvar bounds;\r\n\r\n\t\t// Update the shape based on the current position of this corner and the opposite point\r\n\t\tthis._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));\r\n\r\n\t\t// Reposition the move marker\r\n\t\tbounds = this._shape.getBounds();\r\n\t\tthis._moveMarker.setLatLng(bounds.getCenter());\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });\r\n\t},\r\n\r\n\t_getCorners: function () {\r\n\t\tvar bounds = this._shape.getBounds(),\r\n\t\t\tnw = bounds.getNorthWest(),\r\n\t\t\tne = bounds.getNorthEast(),\r\n\t\t\tse = bounds.getSouthEast(),\r\n\t\t\tsw = bounds.getSouthWest();\r\n\r\n\t\treturn [nw, ne, se, sw];\r\n\t},\r\n\r\n\t_toggleCornerMarkers: function (opacity) {\r\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers[i].setOpacity(opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_repositionCornerMarkers: function () {\r\n\t\tvar corners = this._getCorners();\r\n\r\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers[i].setLatLng(corners[i]);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Rectangle.addInitHook(function () {\r\n\tif (L.Edit.Rectangle) {\r\n\t\tthis.editing = new L.Edit.Rectangle(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.CircleMarker\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.CircleMarker = L.Edit.SimpleShape.extend({\r\n\t_createMoveMarker: function () {\r\n\t\tvar center = this._shape.getLatLng();\r\n\r\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\r\n\t\tthis._resizeMarkers = [];\r\n\t},\r\n\r\n\t_move: function (latlng) {\r\n\t\tif (this._resizeMarkers.length) {\r\n\t\t\t\tvar resizemarkerPoint = this._getResizeMarkerPoint(latlng);\r\n\t\t\t\t// Move the resize marker\r\n\t\t\t\tthis._resizeMarkers[0].setLatLng(resizemarkerPoint);\r\n\t\t}\r\n\r\n\t\t// Move the circle\r\n\t\tthis._shape.setLatLng(latlng);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });\r\n\t},\r\n});\r\n\r\nL.CircleMarker.addInitHook(function () {\r\n\tif (L.Edit.CircleMarker) {\r\n\t\tthis.editing = new L.Edit.CircleMarker(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on('add', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on('remove', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\n/**\n * @class L.Edit.Circle\n * @aka Edit.Circle\n * @inherits L.Edit.CircleMarker\n */\nL.Edit.Circle = L.Edit.CircleMarker.extend({\n\n\t_createResizeMarker: function () {\n\t\tvar center = this._shape.getLatLng(),\n\t\t\tresizemarkerPoint = this._getResizeMarkerPoint(center);\n\n\t\tthis._resizeMarkers = [];\n\t\tthis._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));\n\t},\n\n\t_getResizeMarkerPoint: function (latlng) {\n\t\t// From L.shape.getBounds()\n\t\tvar delta = this._shape._radius * Math.cos(Math.PI / 4),\n\t\t\tpoint = this._map.project(latlng);\n\t\treturn this._map.unproject([point.x + delta, point.y - delta]);\n\t},\n\n\t_resize: function (latlng) {\n\t\tvar moveLatLng = this._moveMarker.getLatLng(),\n\t\t\tradius = this._map.distance(moveLatLng, latlng);\n\n\t\tthis._shape.setRadius(radius);\n\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });\n\t}\n});\n\nL.Circle.addInitHook(function () {\n\tif (L.Edit.Circle) {\n\t\tthis.editing = new L.Edit.Circle(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n\n\tthis.on('add', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.addHooks();\n\t\t}\n\t});\n\n\tthis.on('remove', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.removeHooks();\n\t\t}\n\t});\n});\n","L.Map.mergeOptions({\r\n\ttouchExtend: true\r\n});\r\n\r\n/**\r\n * @class L.Map.TouchExtend\r\n * @aka TouchExtend\r\n */\r\nL.Map.TouchExtend = L.Handler.extend({\r\n\r\n\t// @method initialize(): void\r\n\t// Sets TouchExtend private accessor variables\r\n\tinitialize: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._container = map._container;\r\n\t\tthis._pane = map._panes.overlayPane;\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Adds dom listener events to the map container\r\n\taddHooks: function () {\r\n\t\tL.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);\r\n\t\tL.DomEvent.on(this._container, 'touchend', this._onTouchEnd, this);\r\n\t\tL.DomEvent.on(this._container, 'touchmove', this._onTouchMove, this);\r\n\t\tif (this._detectIE()) {\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerDown', this._onTouchStart, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerUp', this._onTouchEnd, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerMove', this._onTouchMove, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerCancel', this._onTouchCancel, this);\r\n\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(this._container, 'touchcancel', this._onTouchCancel, this);\r\n\t\t\tL.DomEvent.on(this._container, 'touchleave', this._onTouchLeave, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Removes dom listener events from the map container\r\n\tremoveHooks: function () {\r\n\t\tL.DomEvent.off(this._container, 'touchstart', this._onTouchStart);\r\n\t\tL.DomEvent.off(this._container, 'touchend', this._onTouchEnd);\r\n\t\tL.DomEvent.off(this._container, 'touchmove', this._onTouchMove);\r\n\t\tif (this._detectIE()) {\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerDowm', this._onTouchStart);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerUp', this._onTouchEnd);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerMove', this._onTouchMove);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerCancel', this._onTouchCancel);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.off(this._container, 'touchcancel', this._onTouchCancel);\r\n\t\t\tL.DomEvent.off(this._container, 'touchleave', this._onTouchLeave);\r\n\t\t}\r\n\t},\r\n\r\n\t_touchEvent: function (e, type) {\r\n\t\t// #TODO: fix the pageX error that is do a bug in Android where a single touch triggers two click events\r\n\t\t// _filterClick is what leaflet uses as a workaround.\r\n\t\t// This is a problem with more things than just android. Another problem is touchEnd has no touches in\r\n\t\t// its touch list.\r\n\t\tvar touchEvent = {};\r\n\t\tif (typeof e.touches !== 'undefined') {\r\n\t\t\tif (!e.touches.length) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttouchEvent = e.touches[0];\r\n\t\t} else if (e.pointerType === 'touch') {\r\n\t\t\ttouchEvent = e;\r\n\t\t\tif (!this._filterClick(e)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this._map.mouseEventToContainerPoint(touchEvent),\r\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis._map.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\tpageX: touchEvent.pageX,\r\n\t\t\tpageY: touchEvent.pageY,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t/** Borrowed from Leaflet and modified for bool ops **/\r\n\t_filterClick: function (e) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_onTouchStart: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchstart';\r\n\t\tthis._touchEvent(e, type);\r\n\r\n\t},\r\n\r\n\t_onTouchEnd: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchend';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchCancel: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchcancel';\r\n\t\tif (this._detectIE()) {\r\n\t\t\ttype = 'pointercancel';\r\n\t\t}\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchLeave: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchleave';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchmove';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_detectIE: function () {\r\n\t\tvar ua = window.navigator.userAgent;\r\n\r\n\t\tvar msie = ua.indexOf('MSIE ');\r\n\t\tif (msie > 0) {\r\n\t\t\t// IE 10 or older => return version number\r\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n\t\t}\r\n\r\n\t\tvar trident = ua.indexOf('Trident/');\r\n\t\tif (trident > 0) {\r\n\t\t\t// IE 11 => return version number\r\n\t\t\tvar rv = ua.indexOf('rv:');\r\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n\t\t}\r\n\r\n\t\tvar edge = ua.indexOf('Edge/');\r\n\t\tif (edge > 0) {\r\n\t\t\t// IE 12 => return version number\r\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n\t\t}\r\n\r\n\t\t// other browser\r\n\t\treturn false;\r\n\t}\r\n});\r\n\r\nL.Map.addInitHook('addHandler', 'touchExtend', L.Map.TouchExtend);\r\n\r\n\r\n/**\r\n * @class L.Marker.Touch\r\n * @aka Marker.Touch\r\n *\r\n * This isn't full Touch support. This is just to get markers to also support dom touch events after creation\r\n * #TODO: find a better way of getting markers to support touch.\r\n */\r\nL.Marker.Touch = L.Marker.extend({\r\n\r\n\t_initInteraction: function () {\r\n\t\tif (!this.addInteractiveTarget) {\r\n\t\t\t// 0.7.x support\r\n\t\t\treturn this._initInteractionLegacy();\r\n\t\t}\r\n\t\t// TODO this may need be updated to re-add touch events for 1.0+\r\n\t\treturn L.Marker.prototype._initInteraction.apply(this);\r\n\t},\r\n\r\n\t// This is an exact copy of https://github.com/Leaflet/Leaflet/blob/v0.7/src/layer/marker/Marker.js\r\n\t// with the addition of the touch events\r\n\t_initInteractionLegacy: function () {\r\n\r\n\t\tif (!this.options.clickable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t\tevents = ['dblclick',\r\n\t\t\t\t\t  'mousedown',\r\n\t\t\t\t\t  'mouseover',\r\n\t\t\t\t\t  'mouseout',\r\n\t\t\t\t\t  'contextmenu',\r\n\t\t\t\t\t  'touchstart',\r\n\t\t\t\t\t  'touchend',\r\n\t\t\t\t\t  'touchmove'];\r\n\t\tif (this._detectIE) {\r\n\t\t\tevents.concat(['MSPointerDown',\r\n\t\t\t\t\t\t   'MSPointerUp',\r\n\t\t\t\t\t\t   'MSPointerMove',\r\n\t\t\t\t\t\t   'MSPointerCancel']);\r\n\t\t} else {\r\n\t\t\tevents.concat(['touchcancel']);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_detectIE: function () {\r\n\t\tvar ua = window.navigator.userAgent;\r\n\r\n\t\tvar msie = ua.indexOf('MSIE ');\r\n\t\tif (msie > 0) {\r\n\t\t\t// IE 10 or older => return version number\r\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n\t\t}\r\n\r\n\t\tvar trident = ua.indexOf('Trident/');\r\n\t\tif (trident > 0) {\r\n\t\t\t// IE 11 => return version number\r\n\t\t\tvar rv = ua.indexOf('rv:');\r\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n\t\t}\r\n\r\n\t\tvar edge = ua.indexOf('Edge/');\r\n\t\tif (edge > 0) {\r\n\t\t\t// IE 12 => return version number\r\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n\t\t}\r\n\r\n\t\t// other browser\r\n\t\treturn false;\r\n\t}\r\n});\r\n","/**\r\n * @class L.LatLngUtil\r\n * @aka LatLngUtil\r\n */\r\nL.LatLngUtil = {\r\n\t// Clones a LatLngs[], returns [][]\r\n\r\n\t// @method cloneLatLngs(LatLngs[]): L.LatLngs[]\r\n\t// Clone the latLng point or points or nested points and return an array with those points\r\n\tcloneLatLngs: function (latlngs) {\r\n\t\tvar clone = [];\r\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\r\n\t\t\t// Check for nested array (Polyline/Polygon)\r\n\t\t\tif (Array.isArray(latlngs[i])) {\r\n\t\t\t\tclone.push(L.LatLngUtil.cloneLatLngs(latlngs[i]));\r\n\t\t\t} else {\r\n\t\t\t\tclone.push(this.cloneLatLng(latlngs[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn clone;\r\n\t},\r\n\r\n\t// @method cloneLatLng(LatLng): L.LatLng\r\n\t// Clone the latLng and return a new LatLng object.\r\n\tcloneLatLng: function (latlng) {\r\n\t\treturn L.latLng(latlng.lat, latlng.lng);\r\n\t}\r\n};\r\n","(function() {\n\nvar defaultPrecision = {\n\tkm: 2,\n\tha: 2,\n\tm: 0,\n\tmi: 2,\n\tac: 2,\n\tyd: 0,\n\tft: 0,\n\tnm: 2\n};\n\n\n/**\n * @class L.GeometryUtil\n * @aka GeometryUtil\n */\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\t// Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270\n\n\t// @method geodesicArea(): number\n\tgeodesicArea: function (latLngs) {\n\t\tvar pointsCount = latLngs.length,\n\t\t\tarea = 0.0,\n\t\t\td2r = Math.PI / 180,\n\t\t\tp1, p2;\n\n\t\tif (pointsCount > 2) {\n\t\t\tfor (var i = 0; i < pointsCount; i++) {\n\t\t\t\tp1 = latLngs[i];\n\t\t\t\tp2 = latLngs[(i + 1) % pointsCount];\n\t\t\t\tarea += ((p2.lng - p1.lng) * d2r) *\n\t\t\t\t\t\t(2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));\n\t\t\t}\n\t\t\tarea = area * 6378137.0 * 6378137.0 / 2.0;\n\t\t}\n\n\t\treturn Math.abs(area);\n\t},\n\n\t// @method formattedNumber(n, precision): string\n\t// Returns n in specified number format (if defined) and precision\n\tformattedNumber: function (n, precision) {\n\t\tvar formatted = parseFloat(n).toFixed(precision),\n\t\t\tformat = L.drawLocal.format && L.drawLocal.format.numeric,\n\t\t\tdelimiters = format && format.delimiters,\n\t\t\tthousands = delimiters && delimiters.thousands,\n\t\t\tdecimal = delimiters && delimiters.decimal;\n\n\t\tif (thousands || decimal) {\n\t\t\tvar splitValue = formatted.split('.');\n\t\t\tformatted = thousands ? splitValue[0].replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + thousands) : splitValue[0];\n\t\t\tdecimal = decimal || '.';\n\t\t\tif (splitValue.length > 1) {\n\t\t\t\tformatted = formatted + decimal + splitValue[1];\n\t\t\t}\n\t\t}\n\n\t\treturn formatted;\n\t},\n\n\t// @method readableArea(area, isMetric, precision): string\n\t// Returns a readable area string in yards or metric.\n\t// The value will be rounded as defined by the precision option object.\n\treadableArea: function (area, isMetric, precision) {\n\t\tvar areaStr,\n\t\t\tunits,\n\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\tif (isMetric) {\n\t\t\tunits = ['ha', 'm'];\n\t\t\ttype = typeof isMetric;\n\t\t\tif (type === 'string') {\n\t\t\t\tunits = [isMetric];\n\t\t\t} else if (type !== 'boolean') {\n\t\t\t\tunits = isMetric;\n\t\t\t}\n\n\t\t\tif (area >= 1000000 && units.indexOf('km') !== -1) {\n\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.000001, precision['km']) + ' km²';\n\t\t\t} else if (area >= 10000 && units.indexOf('ha') !== -1) {\n\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.0001, precision['ha']) + ' ha';\n\t\t\t} else {\n\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['m']) + ' m²';\n\t\t\t}\n\t\t} else {\n\t\t\tarea /= 0.836127; // Square yards in 1 meter\n\n\t\t\tif (area >= 3097600) { //3097600 square yards in 1 square mile\n\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 3097600, precision['mi']) + ' mi²';\n\t\t\t} else if (area >= 4840) { //4840 square yards in 1 acre\n\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 4840, precision['ac']) + ' acres';\n\t\t\t} else {\n\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['yd']) + ' yd²';\n\t\t\t}\n\t\t}\n\n\t\treturn areaStr;\n\t},\n\n\t// @method readableDistance(distance, units): string\n\t// Converts a metric distance to one of [ feet, nauticalMile, metric or yards ] string\n\t//\n\t// @alternative\n\t// @method readableDistance(distance, isMetric, useFeet, isNauticalMile, precision): string\n\t// Converts metric distance to distance string.\n\t// The value will be rounded as defined by the precision option object.\n\treadableDistance: function (distance, isMetric, isFeet, isNauticalMile, precision) {\n\t\tvar distanceStr,\n\t\t\tunits,\n\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\tif (isMetric) {\n\t\t\tunits = typeof isMetric == 'string' ? isMetric : 'metric';\n\t\t} else if (isFeet) {\n\t\t\tunits = 'feet';\n\t\t} else if (isNauticalMile) {\n\t\t\tunits = 'nauticalMile';\n\t\t} else {\n\t\t\tunits = 'yards';\n\t\t}\n\n\t\tswitch (units) {\n\t\tcase 'metric':\n\t\t\t// show metres when distance is < 1km, then show km\n\t\t\tif (distance > 1000) {\n\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['km']) + ' km';\n\t\t\t} else {\n\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['m']) + ' m';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'feet':\n\t\t\tdistance *= 1.09361 * 3;\n\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['ft']) + ' ft';\n\n\t\t\tbreak;\n\t\tcase 'nauticalMile':\n\t\t\tdistance *= 0.53996;\n\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['nm']) + ' nm';\n\t\t\tbreak;\n\t\tcase 'yards':\n\t\tdefault:\n\t\t\tdistance *= 1.09361;\n\n\t\t\tif (distance > 1760) {\n\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1760, precision['mi']) + ' miles';\n\t\t\t} else {\n\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['yd']) + ' yd';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn distanceStr;\n\t}\n});\n\n})();\n","/**\r\n * @class L.LineUtil\r\n * @aka Util\r\n * @aka L.Utils\r\n */\r\nL.Util.extend(L.LineUtil, {\r\n\r\n\t// @method segmentsIntersect(): boolean\r\n\t// Checks to see if two line segments intersect. Does not handle degenerate cases.\r\n\t// http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\r\n\tsegmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {\r\n\t\treturn this._checkCounterclockwise(p, p2, p3) !==\r\n\t\t\t   this._checkCounterclockwise(p1, p2, p3) &&\r\n\t\t\t   this._checkCounterclockwise(p, p1, p2) !==\r\n\t\t\t   this._checkCounterclockwise(p, p1, p3);\r\n\t},\r\n\r\n\t// check to see if points are in counterclockwise order\r\n\t_checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);\r\n\t}\r\n});","/**\r\n * @class L.Polyline\r\n * @aka Polyline\r\n */\r\nL.Polyline.include({\r\n\r\n\t// @method intersects(): boolean\r\n\t// Check to see if this polyline has any linesegments that intersect.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tintersects: function () {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0,\r\n\t\t\ti, p, p1;\r\n\r\n\t\tif (this._tooFewPointsForIntersection()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (i = len - 1; i >= 3; i--) {\r\n\t\t\tp = points[i - 1];\r\n\t\t\tp1 = points[i];\r\n\r\n\r\n\t\t\tif (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// @method newLatLngIntersects(): boolean\r\n\t// Check for intersection if new latlng was added to this polyline.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tnewLatLngIntersects: function (latlng, skipFirst) {\r\n\t\t// Cannot check a polyline for intersecting lats/lngs when not added to the map\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\r\n\t},\r\n\r\n\t// @method newPointIntersects(): boolean\r\n\t// Check for intersection if new point was added to this polyline.\r\n\t// newPoint must be a layer point.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tnewPointIntersects: function (newPoint, skipFirst) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0,\r\n\t\t\tlastPoint = points ? points[len - 1] : null,\r\n\t\t\t// The previous previous line segment. Previous line segment doesn't need testing.\r\n\t\t\tmaxIndex = len - 2;\r\n\r\n\t\tif (this._tooFewPointsForIntersection(1)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\r\n\t},\r\n\r\n\t// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\r\n\t// Cannot have intersection when < 3 line segments (< 4 points)\r\n\t_tooFewPointsForIntersection: function (extraPoints) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0;\r\n\t\t// Increment length by extraPoints if present\r\n\t\tlen += extraPoints || 0;\r\n\r\n\t\treturn !points || len <= 3;\r\n\t},\r\n\r\n\t// Checks a line segment intersections with any line segments before its predecessor.\r\n\t// Don't need to check the predecessor as will never intersect.\r\n\t_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tp2, p3;\r\n\r\n\t\tminIndex = minIndex || 0;\r\n\r\n\t\t// Check all previous line segments (beside the immediately previous) for intersections\r\n\t\tfor (var j = maxIndex; j > minIndex; j--) {\r\n\t\t\tp2 = points[j - 1];\r\n\t\t\tp3 = points[j];\r\n\r\n\t\t\tif (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_getProjectedPoints: function () {\r\n\t\tif (!this._defaultShape) {\r\n\t\t\treturn this._originalPoints;\r\n\t\t}\r\n\t\tvar points = [],\r\n\t\t\t_shape = this._defaultShape();\r\n\r\n\t\tfor (var i = 0; i < _shape.length; i++) {\r\n\t\t\tpoints.push(this._map.latLngToLayerPoint(_shape[i]));\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n});\r\n","/**\r\n * @class L.Polygon\r\n * @aka Polygon\r\n */\r\nL.Polygon.include({\r\n\r\n\t// @method intersects(): boolean\r\n\t// Checks a polygon for any intersecting line segments. Ignores holes.\r\n\tintersects: function () {\r\n\t\tvar polylineIntersects,\r\n\t\t\tpoints = this._getProjectedPoints(),\r\n\t\t\tlen, firstPoint, lastPoint, maxIndex;\r\n\r\n\t\tif (this._tooFewPointsForIntersection()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tpolylineIntersects = L.Polyline.prototype.intersects.call(this);\r\n\r\n\t\t// If already found an intersection don't need to check for any more.\r\n\t\tif (polylineIntersects) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlen = points.length;\r\n\t\tfirstPoint = points[0];\r\n\t\tlastPoint = points[len - 1];\r\n\t\tmaxIndex = len - 2;\r\n\r\n\t\t// Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)\r\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Control.Draw\r\n * @aka L.Draw\r\n */\r\nL.Control.Draw = L.Control.extend({\r\n\r\n\t// Options\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tdraw: {},\r\n\t\tedit: false\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\t// Initializes draw control, toolbars from the options\r\n\tinitialize: function (options) {\r\n\t\tif (L.version < '0.7') {\r\n\t\t\tthrow new Error('Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/');\r\n\t\t}\r\n\r\n\t\tL.Control.prototype.initialize.call(this, options);\r\n\r\n\t\tvar toolbar;\r\n\r\n\t\tthis._toolbars = {};\r\n\r\n\t\t// Initialize toolbars\r\n\t\tif (L.DrawToolbar && this.options.draw) {\r\n\t\t\ttoolbar = new L.DrawToolbar(this.options.draw);\r\n\r\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE] = toolbar;\r\n\r\n\t\t\t// Listen for when toolbar is enabled\r\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE].on('enable', this._toolbarEnabled, this);\r\n\t\t}\r\n\r\n\t\tif (L.EditToolbar && this.options.edit) {\r\n\t\t\ttoolbar = new L.EditToolbar(this.options.edit);\r\n\r\n\t\t\tthis._toolbars[L.EditToolbar.TYPE] = toolbar;\r\n\r\n\t\t\t// Listen for when toolbar is enabled\r\n\t\t\tthis._toolbars[L.EditToolbar.TYPE].on('enable', this._toolbarEnabled, this);\r\n\t\t}\r\n\t\tL.toolbar = this; //set global var for editing the toolbar\r\n\t},\r\n\r\n\t// @method onAdd(): container\r\n\t// Adds the toolbar container to the map\r\n\tonAdd: function (map) {\r\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw'),\r\n\t\t\taddedTopClass = false,\r\n\t\t\ttopClassName = 'leaflet-draw-toolbar-top',\r\n\t\t\ttoolbarContainer;\r\n\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\r\n\t\t\t\ttoolbarContainer = this._toolbars[toolbarId].addToolbar(map);\r\n\r\n\t\t\t\tif (toolbarContainer) {\r\n\t\t\t\t\t// Add class to the first toolbar to remove the margin\r\n\t\t\t\t\tif (!addedTopClass) {\r\n\t\t\t\t\t\tif (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {\r\n\t\t\t\t\t\t\tL.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\taddedTopClass = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontainer.appendChild(toolbarContainer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method onRemove(): void\r\n\t// Removes the toolbars from the map toolbar container\r\n\tonRemove: function () {\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\r\n\t\t\t\tthis._toolbars[toolbarId].removeToolbar();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// @method setDrawingOptions(options): void\r\n\t// Sets options to all toolbar instances\r\n\tsetDrawingOptions: function (options) {\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars[toolbarId] instanceof L.DrawToolbar) {\r\n\t\t\t\tthis._toolbars[toolbarId].setOptions(options);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_toolbarEnabled: function (e) {\r\n\t\tvar enabledToolbar = e.target;\r\n\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars[toolbarId] !== enabledToolbar) {\r\n\t\t\t\tthis._toolbars[toolbarId].disable();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tdrawControlTooltips: true,\r\n\tdrawControl: false\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.drawControl) {\r\n\t\tthis.drawControl = new L.Control.Draw();\r\n\t\tthis.addControl(this.drawControl);\r\n\t}\r\n});\r\n","/**\n * @class L.Draw.Toolbar\n * @aka Toolbar\n *\n * The toolbar class of the API — it is used to create the ui\n * This will be depreciated\n *\n * @example\n *\n * ```js\n *    var toolbar = L.Toolbar();\n *    toolbar.addToolbar(map);\n * ```\n *\n * ### Disabling a toolbar\n *\n * If you do not want a particular toolbar in your app you can turn it off by setting the toolbar to false.\n *\n * ```js\n *      var drawControl = new L.Control.Draw({\n *          draw: false,\n *          edit: {\n *              featureGroup: editableLayers\n *          }\n *      });\n * ```\n *\n * ### Disabling a toolbar item\n *\n * If you want to turn off a particular toolbar item, set it to false. The following disables drawing polygons and\n * markers. It also turns off the ability to edit layers.\n *\n * ```js\n *      var drawControl = new L.Control.Draw({\n *          draw: {\n *              polygon: false,\n *              marker: false\n *          },\n *          edit: {\n *              featureGroup: editableLayers,\n *              edit: false\n *          }\n *      });\n * ```\n */\nL.Toolbar = L.Class.extend({\n\tincludes: [L.Mixin.Events],\n\n\t// @section Methods for modifying the toolbar\n\n\t// @method initialize(options): void\n\t// Toolbar constructor\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._modes = {};\n\t\tthis._actionButtons = [];\n\t\tthis._activeMode = null;\n\t},\n\n\t// @method enabled(): boolean\n\t// Gets a true/false of whether the toolbar is enabled\n\tenabled: function () {\n\t\treturn this._activeMode !== null;\n\t},\n\n\t// @method disable(): void\n\t// Disables the toolbar\n\tdisable: function () {\n\t\tif (!this.enabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._activeMode.handler.disable();\n\t},\n\n\t// @method addToolbar(map): L.DomUtil\n\t// Adds the toolbar to the map and returns the toolbar dom element\n\taddToolbar: function (map) {\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw-section'),\n\t\t\tbuttonIndex = 0,\n\t\t\tbuttonClassPrefix = this._toolbarClass || '',\n\t\t\tmodeHandlers = this.getModeHandlers(map),\n\t\t\ti;\n\n\t\tthis._toolbarContainer = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');\n\t\tthis._map = map;\n\n\t\tfor (i = 0; i < modeHandlers.length; i++) {\n\t\t\tif (modeHandlers[i].enabled) {\n\t\t\t\tthis._initModeHandler(\n\t\t\t\t\tmodeHandlers[i].handler,\n\t\t\t\t\tthis._toolbarContainer,\n\t\t\t\t\tbuttonIndex++,\n\t\t\t\t\tbuttonClassPrefix,\n\t\t\t\t\tmodeHandlers[i].title\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// if no buttons were added, do not add the toolbar\n\t\tif (!buttonIndex) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Save button index of the last button, -1 as we would have ++ after the last button\n\t\tthis._lastButtonIndex = --buttonIndex;\n\n\t\t// Create empty actions part of the toolbar\n\t\tthis._actionsContainer = L.DomUtil.create('ul', 'leaflet-draw-actions');\n\n\t\t// Add draw and cancel containers to the control container\n\t\tcontainer.appendChild(this._toolbarContainer);\n\t\tcontainer.appendChild(this._actionsContainer);\n\n\t\treturn container;\n\t},\n\n\t// @method removeToolbar(): void\n\t// Removes the toolbar and drops the handler event listeners\n\tremoveToolbar: function () {\n\t\t// Dispose each handler\n\t\tfor (var handlerId in this._modes) {\n\t\t\tif (this._modes.hasOwnProperty(handlerId)) {\n\t\t\t\t// Unbind handler button\n\t\t\t\tthis._disposeButton(\n\t\t\t\t\tthis._modes[handlerId].button,\n\t\t\t\t\tthis._modes[handlerId].handler.enable,\n\t\t\t\t\tthis._modes[handlerId].handler\n\t\t\t\t);\n\n\t\t\t\t// Make sure is disabled\n\t\t\t\tthis._modes[handlerId].handler.disable();\n\n\t\t\t\t// Unbind handler\n\t\t\t\tthis._modes[handlerId].handler\n\t\t\t\t\t.off('enabled', this._handlerActivated, this)\n\t\t\t\t\t.off('disabled', this._handlerDeactivated, this);\n\t\t\t}\n\t\t}\n\t\tthis._modes = {};\n\n\t\t// Dispose the actions toolbar\n\t\tfor (var i = 0, l = this._actionButtons.length; i < l; i++) {\n\t\t\tthis._disposeButton(\n\t\t\t\tthis._actionButtons[i].button,\n\t\t\t\tthis._actionButtons[i].callback,\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\t\tthis._actionButtons = [];\n\t\tthis._actionsContainer = null;\n\t},\n\n\t_initModeHandler: function (handler, container, buttonIndex, classNamePredix, buttonTitle) {\n\t\tvar type = handler.type;\n\n\t\tthis._modes[type] = {};\n\n\t\tthis._modes[type].handler = handler;\n\n\t\tthis._modes[type].button = this._createButton({\n\t\t\ttype: type,\n\t\t\ttitle: buttonTitle,\n\t\t\tclassName: classNamePredix + '-' + type,\n\t\t\tcontainer: container,\n\t\t\tcallback: this._modes[type].handler.enable,\n\t\t\tcontext: this._modes[type].handler\n\t\t});\n\n\t\tthis._modes[type].buttonIndex = buttonIndex;\n\n\t\tthis._modes[type].handler\n\t\t\t.on('enabled', this._handlerActivated, this)\n\t\t\t.on('disabled', this._handlerDeactivated, this);\n\t},\n\n\t/* Detect iOS based on browser User Agent, based on:\n\t * http://stackoverflow.com/a/9039885 */\n\t_detectIOS: function () {\n\t\tvar iOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);\n\t\treturn iOS;\n\t},\n\n\t_createButton: function (options) {\n\n\t\tvar link = L.DomUtil.create('a', options.className || '', options.container);\n\t\t// Screen reader tag\n\t\tvar sr = L.DomUtil.create('span', 'sr-only', options.container);\n\n\t\tlink.href = '#';\n\t\tlink.appendChild(sr);\n\n\t\tif (options.title) {\n\t\t\tlink.title = options.title;\n\t\t\tsr.innerHTML = options.title;\n\t\t}\n\n\t\tif (options.text) {\n\t\t\tlink.innerHTML = options.text;\n\t\t\tsr.innerHTML = options.text;\n\t\t}\n\n\t\t/* iOS does not use click events */\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\n\n\t\tL.DomEvent\n\t\t\t.on(link, 'click', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'mousedown', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'dblclick', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'touchstart', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'click', L.DomEvent.preventDefault)\n\t\t\t.on(link, buttonEvent, options.callback, options.context);\n\n\t\treturn link;\n\t},\n\n\t_disposeButton: function (button, callback) {\n\t\t/* iOS does not use click events */\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\n\n\t\tL.DomEvent\n\t\t\t.off(button, 'click', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'mousedown', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'dblclick', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'touchstart', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'click', L.DomEvent.preventDefault)\n\t\t\t.off(button, buttonEvent, callback);\n\t},\n\n\t_handlerActivated: function (e) {\n\t\t// Disable active mode (if present)\n\t\tthis.disable();\n\n\t\t// Cache new active feature\n\t\tthis._activeMode = this._modes[e.handler];\n\n\t\tL.DomUtil.addClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n\t\tthis._showActionsToolbar();\n\n\t\tthis.fire('enable');\n\t},\n\n\t_handlerDeactivated: function () {\n\t\tthis._hideActionsToolbar();\n\n\t\tL.DomUtil.removeClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n\t\tthis._activeMode = null;\n\n\t\tthis.fire('disable');\n\t},\n\n\t_createActions: function (handler) {\n\t\tvar container = this._actionsContainer,\n\t\t\tbuttons = this.getActions(handler),\n\t\t\tl = buttons.length,\n\t\t\tli, di, dl, button;\n\n\t\t// Dispose the actions toolbar (todo: dispose only not used buttons)\n\t\tfor (di = 0, dl = this._actionButtons.length; di < dl; di++) {\n\t\t\tthis._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);\n\t\t}\n\t\tthis._actionButtons = [];\n\n\t\t// Remove all old buttons\n\t\twhile (container.firstChild) {\n\t\t\tcontainer.removeChild(container.firstChild);\n\t\t}\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif ('enabled' in buttons[i] && !buttons[i].enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tli = L.DomUtil.create('li', '', container);\n\n\t\t\tbutton = this._createButton({\n\t\t\t\ttitle: buttons[i].title,\n\t\t\t\ttext: buttons[i].text,\n\t\t\t\tcontainer: li,\n\t\t\t\tcallback: buttons[i].callback,\n\t\t\t\tcontext: buttons[i].context\n\t\t\t});\n\n\t\t\tthis._actionButtons.push({\n\t\t\t\tbutton: button,\n\t\t\t\tcallback: buttons[i].callback\n\t\t\t});\n\t\t}\n\t},\n\n\t_showActionsToolbar: function () {\n\t\tvar buttonIndex = this._activeMode.buttonIndex,\n\t\t\tlastButtonIndex = this._lastButtonIndex,\n\t\t\ttoolbarPosition = this._activeMode.button.offsetTop - 1;\n\n\t\t// Recreate action buttons on every click\n\t\tthis._createActions(this._activeMode.handler);\n\n\t\t// Correctly position the cancel button\n\t\tthis._actionsContainer.style.top = toolbarPosition + 'px';\n\n\t\tif (buttonIndex === 0) {\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-top');\n\t\t}\n\n\t\tif (buttonIndex === lastButtonIndex) {\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n\t\t}\n\n\t\tthis._actionsContainer.style.display = 'block';\n\t},\n\n\t_hideActionsToolbar: function () {\n\t\tthis._actionsContainer.style.display = 'none';\n\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-top');\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n\t}\n});\n","L.Draw = L.Draw || {};\r\n/**\r\n * @class L.Draw.Tooltip\r\n * @aka Tooltip\r\n *\r\n * The tooltip class — it is used to display the tooltip while drawing\r\n * This will be depreciated\r\n *\r\n * @example\r\n *\r\n * ```js\r\n *    var tooltip = L.Draw.Tooltip();\r\n * ```\r\n *\r\n */\r\nL.Draw.Tooltip = L.Class.extend({\r\n\r\n\t// @section Methods for modifying draw state\r\n\r\n\t// @method initialize(map): void\r\n\t// Tooltip constructor\r\n\tinitialize: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._popupPane = map._panes.popupPane;\r\n\t\tthis._visible = false;\r\n\r\n\t\tthis._container = map.options.drawControlTooltips ?\r\n\t\t\tL.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;\r\n\t\tthis._singleLineLabel = false;\r\n\r\n\t\tthis._map.on('mouseout', this._onMouseOut, this);\r\n\t},\r\n\r\n\t// @method dispose(): void\r\n\t// Remove Tooltip DOM and unbind events\r\n\tdispose: function () {\r\n\t\tthis._map.off('mouseout', this._onMouseOut, this);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._popupPane.removeChild(this._container);\r\n\t\t\tthis._container = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// @method updateContent(labelText): this\r\n\t// Changes the tooltip text to string in function call\r\n\tupdateContent: function (labelText) {\r\n\t\tif (!this._container) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tlabelText.subtext = labelText.subtext || '';\r\n\r\n\t\t// update the vertical position (only if changed)\r\n\t\tif (labelText.subtext.length === 0 && !this._singleLineLabel) {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');\r\n\t\t\tthis._singleLineLabel = true;\r\n\t\t}\r\n\t\telse if (labelText.subtext.length > 0 && this._singleLineLabel) {\r\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');\r\n\t\t\tthis._singleLineLabel = false;\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML =\r\n\t\t\t(labelText.subtext.length > 0 ?\r\n\t\t\t'<span class=\"leaflet-draw-tooltip-subtext\">' + labelText.subtext + '</span>' + '<br />' : '') +\r\n\t\t\t'<span>' + labelText.text + '</span>';\r\n\r\n\t\tif (!labelText.text && !labelText.subtext) {\r\n\t\t\tthis._visible = false;\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\t} else {\r\n\t\t\tthis._visible = true;\r\n\t\t\tthis._container.style.visibility = 'inherit';\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method updatePosition(latlng): this\r\n\t// Changes the location of the tooltip\r\n\tupdatePosition: function (latlng) {\r\n\t\tvar pos = this._map.latLngToLayerPoint(latlng),\r\n\t\t\ttooltipContainer = this._container;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tif (this._visible) {\r\n\t\t\t\ttooltipContainer.style.visibility = 'inherit';\r\n\t\t\t}\r\n\t\t\tL.DomUtil.setPosition(tooltipContainer, pos);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method showAsError(): this\r\n\t// Applies error class to tooltip\r\n\tshowAsError: function () {\r\n\t\tif (this._container) {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method removeError(): this\r\n\t// Removes the error class from the tooltip\r\n\tremoveError: function () {\r\n\t\tif (this._container) {\r\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_onMouseOut: function () {\r\n\t\tif (this._container) {\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\t}\r\n\t}\r\n});\r\n","/**\n * @class L.DrawToolbar\n * @aka Toolbar\n */\nL.DrawToolbar = L.Toolbar.extend({\n\n\tstatics: {\n\t\tTYPE: 'draw'\n\t},\n\n\toptions: {\n\t\tpolyline: {},\n\t\tpolygon: {},\n\t\trectangle: {},\n\t\tcircle: {},\n\t\tmarker: {},\n\t\tcirclemarker: {},\n\t\tcloud: {},\n\t\tarrow: {}\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (options) {\n\t\t// Ensure that the options are merged correctly since L.extend is only shallow\n\t\tfor (var type in this.options) {\n\t\t\tif (this.options.hasOwnProperty(type)) {\n\t\t\t\tif (options[type]) {\n\t\t\t\t\toptions[type] = L.extend({}, this.options[type], options[type]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._toolbarClass = 'leaflet-draw-draw';\n\t\tL.Toolbar.prototype.initialize.call(this, options);\n\t},\n\n\t// @method getModeHandlers(): object\n\t// Get mode handlers information\n\tgetModeHandlers: function (map) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: this.options.polyline,\n\t\t\t\thandler: new L.Draw.Polyline(map, this.options.polyline),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polyline\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.polygon,\n\t\t\t\thandler: new L.Draw.Polygon(map, this.options.polygon),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polygon\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.rectangle,\n\t\t\t\thandler: new L.Draw.Rectangle(map, this.options.rectangle),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.rectangle\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.circle,\n\t\t\t\thandler: new L.Draw.Circle(map, this.options.circle),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circle\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.marker,\n\t\t\t\thandler: new L.Draw.Marker(map, this.options.marker),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.marker\n\t\t\t},\n            {\n                enabled: this.options.circlemarker,\n                handler: new L.Draw.CircleMarker(map, this.options.circlemarker),\n                title: L.drawLocal.draw.toolbar.buttons.circlemarker\n            },\n            {\n                enabled: this.options.cloud,\n                handler: new L.Draw.Cloud(map, this.options.cloud),\n                title: \"Cloud\"\n            },\n            {\n                enabled: this.options.arrow,\n                handler: new L.Draw.Arrow(map, this.options.arrow),\n                title: \"Arrow\"\n            }\n\t\t];\n\t},\n\n\t// @method getActions(): object\n\t// Get action information\n\tgetActions: function (handler) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: handler.completeShape,\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.finish.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.finish.text,\n\t\t\t\tcallback: handler.completeShape,\n\t\t\t\tcontext: handler\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: handler.deleteLastVertex,\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.undo.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.undo.text,\n\t\t\t\tcallback: handler.deleteLastVertex,\n\t\t\t\tcontext: handler\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.actions.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.actions.text,\n\t\t\t\tcallback: this.disable,\n\t\t\t\tcontext: this\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method setOptions(): void\n\t// Sets the options to the toolbar\n\tsetOptions: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tfor (var type in this._modes) {\n\t\t\tif (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {\n\t\t\t\tthis._modes[type].handler.setOptions(options[type]);\n\t\t\t}\n\t\t}\n\t}\n});\n","/*L.Map.mergeOptions({\r\n editControl: true\r\n });*/\r\n/**\r\n * @class L.EditToolbar\r\n * @aka EditToolbar\r\n */\r\nL.EditToolbar = L.Toolbar.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'edit'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tedit: {\r\n\t\t\tselectedPathOptions: {\r\n\t\t\t\tdashArray: '10, 10',\r\n\r\n\t\t\t\tfill: true,\r\n\t\t\t\tfillColor: '#fe57a1',\r\n\t\t\t\tfillOpacity: 0.1,\r\n\r\n\t\t\t\t// Whether to user the existing layers color\r\n\t\t\t\tmaintainColor: false\r\n\t\t\t}\r\n\t\t},\r\n\t\tremove: {},\r\n\t\tpoly: null,\r\n\t\tfeatureGroup: null /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (options) {\r\n\t\t// Need to set this manually since null is an acceptable value here\r\n\t\tif (options.edit) {\r\n\t\t\tif (typeof options.edit.selectedPathOptions === 'undefined') {\r\n\t\t\t\toptions.edit.selectedPathOptions = this.options.edit.selectedPathOptions;\r\n\t\t\t}\r\n\t\t\toptions.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, options.edit.selectedPathOptions);\r\n\t\t}\r\n\r\n\t\tif (options.remove) {\r\n\t\t\toptions.remove = L.extend({}, this.options.remove, options.remove);\r\n\t\t}\r\n\r\n\t\tif (options.poly) {\r\n\t\t\toptions.poly = L.extend({}, this.options.poly, options.poly);\r\n\t\t}\r\n\r\n\t\tthis._toolbarClass = 'leaflet-draw-edit';\r\n\t\tL.Toolbar.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._selectedFeatureCount = 0;\r\n\t},\r\n\r\n\t// @method getModeHandlers(): object\r\n\t// Get mode handlers information\r\n\tgetModeHandlers: function (map) {\r\n\t\tvar featureGroup = this.options.featureGroup;\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.edit,\r\n\t\t\t\thandler: new L.EditToolbar.Edit(map, {\r\n\t\t\t\t\tfeatureGroup: featureGroup,\r\n\t\t\t\t\tselectedPathOptions: this.options.edit.selectedPathOptions,\r\n\t\t\t\t\tpoly: this.options.poly\r\n\t\t\t\t}),\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.edit\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.remove,\r\n\t\t\t\thandler: new L.EditToolbar.Delete(map, {\r\n\t\t\t\t\tfeatureGroup: featureGroup\r\n\t\t\t\t}),\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.remove\r\n\t\t\t}\r\n\t\t];\r\n\t},\r\n\r\n\t// @method getActions(): object\r\n\t// Get actions information\r\n\tgetActions: function (handler) {\r\n\t\tvar actions = [\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.save.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.save.text,\r\n\t\t\t\tcallback: this._save,\r\n\t\t\t\tcontext: this\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.cancel.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.cancel.text,\r\n\t\t\t\tcallback: this.disable,\r\n\t\t\t\tcontext: this\r\n\t\t\t}\r\n\t\t];\r\n\r\n\t\tif (handler.removeAllLayers) {\r\n\t\t\t actions.push({\r\n                 title: L.drawLocal.edit.toolbar.actions.clearAll.title,\r\n                 text: L.drawLocal.edit.toolbar.actions.clearAll.text,\r\n                 callback: this._clearAllLayers,\r\n                 context: this\r\n             });\r\n\t\t}\r\n\r\n\t\treturn actions;\r\n\t},\r\n\r\n\t// @method addToolbar(map): L.DomUtil\r\n\t// Adds the toolbar to the map\r\n\taddToolbar: function (map) {\r\n\t\tvar container = L.Toolbar.prototype.addToolbar.call(this, map);\r\n\r\n\t\tthis._checkDisabled();\r\n\r\n\t\tthis.options.featureGroup.on('layeradd layerremove', this._checkDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method removeToolbar(): void\r\n\t// Removes the toolbar from the map\r\n\tremoveToolbar: function () {\r\n\t\tthis.options.featureGroup.off('layeradd layerremove', this._checkDisabled, this);\r\n\r\n\t\tL.Toolbar.prototype.removeToolbar.call(this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disables the toolbar\r\n\tdisable: function () {\r\n\t\tif (!this.enabled()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._activeMode.handler.revertLayers();\r\n\r\n\t\tL.Toolbar.prototype.disable.call(this);\r\n\t},\r\n\r\n\t_save: function () {\r\n\t\tthis._activeMode.handler.save();\r\n\t\tif (this._activeMode) {\r\n\t\t\tthis._activeMode.handler.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_clearAllLayers:function(){\r\n\t\tthis._activeMode.handler.removeAllLayers();\r\n\t\tif (this._activeMode) {\r\n\t\t\tthis._activeMode.handler.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_checkDisabled: function () {\r\n\t\tvar featureGroup = this.options.featureGroup,\r\n\t\t\thasLayers = featureGroup.getLayers().length !== 0,\r\n\t\t\tbutton;\r\n\r\n\t\tif (this.options.edit) {\r\n\t\t\tbutton = this._modes[L.EditToolbar.Edit.TYPE].button;\r\n\r\n\t\t\tif (hasLayers) {\r\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\r\n\t\t\t}\r\n\r\n\t\t\tbutton.setAttribute(\r\n\t\t\t\t'title',\r\n\t\t\t\thasLayers ?\r\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.edit\r\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.editDisabled\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (this.options.remove) {\r\n\t\t\tbutton = this._modes[L.EditToolbar.Delete.TYPE].button;\r\n\r\n\t\t\tif (hasLayers) {\r\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\r\n\t\t\t}\r\n\r\n\t\t\tbutton.setAttribute(\r\n\t\t\t\t'title',\r\n\t\t\t\thasLayers ?\r\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.remove\r\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.removeDisabled\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.EditToolbar.Edit\r\n * @aka EditToolbar.Edit\r\n */\r\nL.EditToolbar.Edit = L.Handler.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'edit'\r\n\t},\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Handler.prototype.initialize.call(this, map);\r\n\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\t// Store the selectable layer group for ease of access\r\n\t\tthis._featureGroup = options.featureGroup;\r\n\r\n\t\tif (!(this._featureGroup instanceof L.FeatureGroup)) {\r\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\r\n\t\t}\r\n\r\n\t\tthis._uneditedLayerProps = {};\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.EditToolbar.Edit.TYPE;\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enable the edit toolbar\r\n\tenable: function () {\r\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.fire('enabled', { handler: this.type });\r\n\t\t//this disable other handlers\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITSTART, { handler: this.type });\r\n\t\t//allow drawLayer to be updated before beginning edition.\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\t\tthis._featureGroup\r\n\t\t\t.on('layeradd', this._enableLayerEdit, this)\r\n\t\t\t.on('layerremove', this._disableLayerEdit, this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disable the edit toolbar\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._featureGroup\r\n\t\t\t.off('layeradd', this._enableLayerEdit, this)\r\n\t\t\t.off('layerremove', this._disableLayerEdit, this);\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\t\tthis._map.fire(L.Draw.Event.EDITSTOP, { handler: this.type });\r\n\t\tthis.fire('disabled', { handler: this.type });\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks for this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._featureGroup.eachLayer(this._enableLayerEdit, this);\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\t\t\tthis._tooltip.updateContent({\r\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\r\n\t\t\t});\r\n\r\n\t\t\t// Quickly access the tooltip to update for intersection checking\r\n\t\t\tmap._editTooltip = this._tooltip;\r\n\r\n\t\t\tthis._updateTooltip();\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.on('touchmove', this._onMouseMove, this)\r\n\t\t\t\t.on('MSPointerMove', this._onMouseMove, this)\r\n\t\t\t\t.on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks for this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\t// Clean up selected layers.\r\n\t\t\tthis._featureGroup.eachLayer(this._disableLayerEdit, this);\r\n\r\n\t\t\t// Clear the backups of the original layers\r\n\t\t\tthis._uneditedLayerProps = {};\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.off('touchmove', this._onMouseMove, this)\r\n\t\t\t\t.off('MSPointerMove', this._onMouseMove, this)\r\n\t\t\t\t.off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method revertLayers(): void\r\n\t// Revert each layer's geometry changes\r\n\trevertLayers: function () {\r\n\t\tthis._featureGroup.eachLayer(function (layer) {\r\n\t\t\tthis._revertLayer(layer);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t// @method save(): void\r\n\t// Save the layer geometries\r\n\tsave: function () {\r\n\t\tvar editedLayers = new L.LayerGroup();\r\n\t\tthis._featureGroup.eachLayer(function (layer) {\r\n\t\t\tif (layer.edited) {\r\n\t\t\t\teditedLayers.addLayer(layer);\r\n\t\t\t\tlayer.edited = false;\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._map.fire(L.Draw.Event.EDITED, { layers: editedLayers });\r\n\t},\r\n\r\n\t_backupLayer: function (layer) {\r\n\t\tvar id = L.Util.stamp(layer);\r\n\r\n\t\tif (!this._uneditedLayerProps[id]) {\r\n\t\t\t// Polyline, Polygon or Rectangle\r\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.Circle) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),\r\n\t\t\t\t\tradius: layer.getRadius()\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\treturn ({\r\n\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\r\n\t\t});\r\n\t},\r\n\r\n\t_updateTooltip: function () {\r\n\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\t},\r\n\r\n\t_revertLayer: function (layer) {\r\n\t\tvar id = L.Util.stamp(layer);\r\n\t\tlayer.edited = false;\r\n\t\tif (this._uneditedLayerProps.hasOwnProperty(id)) {\r\n\t\t\t// Polyline, Polygon or Rectangle\r\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\r\n\t\t\t\tlayer.setLatLngs(this._uneditedLayerProps[id].latlngs);\r\n\t\t\t} else if (layer instanceof L.Circle) {\r\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\r\n\t\t\t\tlayer.setRadius(this._uneditedLayerProps[id].radius);\r\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker or CircleMarker\r\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\r\n\t\t\t}\r\n\r\n\t\t\tlayer.fire('revert-edited', { layer: layer });\r\n\t\t}\r\n\t},\r\n\r\n\t_enableLayerEdit: function (e) {\r\n\t\tvar layer = e.layer || e.target || e,\r\n\t\t\tpathOptions, poly;\r\n\r\n\t\t// Back up this layer (if haven't before)\r\n\t\tthis._backupLayer(layer);\r\n\r\n\t\tif (this.options.poly) {\r\n\t\t\tpoly = L.Util.extend({}, this.options.poly);\r\n\t\t\tlayer.options.poly = poly;\r\n\t\t}\r\n\r\n\t\t// Set different style for editing mode\r\n\t\tif (this.options.selectedPathOptions) {\r\n\t\t\tpathOptions = L.Util.extend({}, this.options.selectedPathOptions);\r\n\r\n\t\t\t// Use the existing color of the layer\r\n\t\t\tif (pathOptions.maintainColor) {\r\n\t\t\t\tpathOptions.color = layer.options.color;\r\n\t\t\t\tpathOptions.fillColor = layer.options.fillColor;\r\n\t\t\t}\r\n\r\n\t\t\tlayer.options.original = L.extend({}, layer.options);\r\n\t\t\tlayer.options.editing = pathOptions;\r\n\r\n\t\t}\r\n\r\n\t\tif (layer instanceof L.Marker) {\r\n\t\t\tif (layer.editing) {\r\n\t\t\t\tlayer.editing.enable();\r\n\t\t\t}\r\n\t\t\tlayer.dragging.enable();\r\n\t\t\tlayer\r\n\t\t\t\t.on('dragend', this._onMarkerDragEnd)\r\n\t\t\t\t// #TODO: remove when leaflet finally fixes their draggable so it's touch friendly again.\r\n\t\t\t\t.on('touchmove', this._onTouchMove, this)\r\n\t\t\t\t.on('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t\t.on('touchend', this._onMarkerDragEnd, this)\r\n\t\t\t\t.on('MSPointerUp', this._onMarkerDragEnd, this);\r\n\t\t} else {\r\n\t\t\tlayer.editing.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_disableLayerEdit: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.edited = false;\r\n\t\tif (layer.editing) {\r\n\t\t\tlayer.editing.disable();\r\n\t\t}\r\n\r\n\t\tdelete layer.options.editing;\r\n\t\tdelete layer.options.original;\r\n\t\t// Reset layer styles to that of before select\r\n\t\tif (this._selectedPathOptions) {\r\n\t\t\tif (layer instanceof L.Marker) {\r\n\t\t\t\tthis._toggleMarkerHighlight(layer);\r\n\t\t\t} else {\r\n\t\t\t\t// reset the layer style to what is was before being selected\r\n\t\t\t\tlayer.setStyle(layer.options.previousOptions);\r\n\t\t\t\t// remove the cached options for the layer object\r\n\t\t\t\tdelete layer.options.previousOptions;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (layer instanceof L.Marker) {\r\n\t\t\tlayer.dragging.disable();\r\n\t\t\tlayer\r\n\t\t\t\t.off('dragend', this._onMarkerDragEnd, this)\r\n\t\t\t\t.off('touchmove', this._onTouchMove, this)\r\n\t\t\t\t.off('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t\t.off('touchend', this._onMarkerDragEnd, this)\r\n\t\t\t\t.off('MSPointerUp', this._onMarkerDragEnd, this);\r\n\t\t} else {\r\n\t\t\tlayer.editing.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tthis._tooltip.updatePosition(e.latlng);\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar layer = e.target;\r\n\t\tlayer.edited = true;\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: layer });\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar touchEvent = e.originalEvent.changedTouches[0],\r\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\r\n\t\te.target.setLatLng(latlng);\r\n\t},\r\n\r\n\t_hasAvailableLayers: function () {\r\n\t\treturn this._featureGroup.getLayers().length !== 0;\r\n\t}\r\n});\r\n","/**\r\n * @class L.EditToolbar.Delete\r\n * @aka EditToolbar.Delete\r\n */\r\nL.EditToolbar.Delete = L.Handler.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'remove' // not delete as delete is reserved in js\r\n\t},\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Handler.prototype.initialize.call(this, map);\r\n\r\n\t\tL.Util.setOptions(this, options);\r\n\r\n\t\t// Store the selectable layer group for ease of access\r\n\t\tthis._deletableLayers = this.options.featureGroup;\r\n\r\n\t\tif (!(this._deletableLayers instanceof L.FeatureGroup)) {\r\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\r\n\t\t}\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.EditToolbar.Delete.TYPE;\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enable the delete toolbar\r\n\tenable: function () {\r\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.fire('enabled', { handler: this.type });\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DELETESTART, { handler: this.type });\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\r\n\t\tthis._deletableLayers\r\n\t\t\t.on('layeradd', this._enableLayerDelete, this)\r\n\t\t\t.on('layerremove', this._disableLayerDelete, this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disable the delete toolbar\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._deletableLayers\r\n\t\t\t.off('layeradd', this._enableLayerDelete, this)\r\n\t\t\t.off('layerremove', this._disableLayerDelete, this);\r\n\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DELETESTOP, { handler: this.type });\r\n\r\n\t\tthis.fire('disabled', { handler: this.type });\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._deletableLayers.eachLayer(this._enableLayerDelete, this);\r\n\t\t\tthis._deletedLayers = new L.LayerGroup();\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\t\t\tthis._tooltip.updateContent({ text: L.drawLocal.edit.handlers.remove.tooltip.text });\r\n\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._deletableLayers.eachLayer(this._disableLayerDelete, this);\r\n\t\t\tthis._deletedLayers = null;\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method revertLayers(): void\r\n\t// Revert the deleted layers back to their prior state.\r\n\trevertLayers: function () {\r\n\t\t// Iterate of the deleted layers and add them back into the featureGroup\r\n\t\tthis._deletedLayers.eachLayer(function (layer) {\r\n\t\t\tthis._deletableLayers.addLayer(layer);\r\n\t\t\tlayer.fire('revert-deleted', { layer: layer });\r\n\t\t}, this);\r\n\t},\r\n\r\n\t// @method save(): void\r\n\t// Save deleted layers\r\n\tsave: function () {\r\n\t\tthis._map.fire(L.Draw.Event.DELETED, { layers: this._deletedLayers });\r\n\t},\r\n\r\n\t// @method removeAllLayers(): void\r\n\t// Remove all delateable layers\r\n\tremoveAllLayers: function(){\r\n\t\t// Iterate of the delateable layers and add remove them\r\n\t\tthis._deletableLayers.eachLayer(function (layer) {\r\n\t\t\tthis._removeLayer({layer:layer});\r\n\t\t}, this);\r\n\t\tthis.save();\r\n\t},\r\n\r\n\t_enableLayerDelete: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.on('click', this._removeLayer, this);\r\n\t},\r\n\r\n\t_disableLayerDelete: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.off('click', this._removeLayer, this);\r\n\r\n\t\t// Remove from the deleted layers so we can't accidentally revert if the user presses cancel\r\n\t\tthis._deletedLayers.removeLayer(layer);\r\n\t},\r\n\r\n\t_removeLayer: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tthis._deletableLayers.removeLayer(layer);\r\n\r\n\t\tthis._deletedLayers.addLayer(layer);\r\n\r\n\t\tlayer.fire('deleted');\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tthis._tooltip.updatePosition(e.latlng);\r\n\t},\r\n\r\n\t_hasAvailableLayers: function () {\r\n\t\treturn this._deletableLayers.getLayers().length !== 0;\r\n\t}\r\n});\r\n"]}